# 1 计算机系统概论

## 1.1 计算机系统简介

### 1.1.1 计算机的软硬件概念

计算机系统由**硬件**和**软件**两大部分组成

计算机软件可以分为**系统**软件和**应用**软件

系统软件主要用来**管理整个计算机系统**

系统软件包括**标准程序库**、**语言处理程序**、**操作系统**、**服务性程序**、**数据库管理系统**、**网络软件**等等

### 1.1.2 计算机系统的层次结构

![image-20200304095946244](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200304095946244.png)

### 1.1.3 计算机组成和计算机体系结构

计算机体系结构是指程序员所见到的**计算机系统的属性**，即概念性结构与功能特性，如指令系统、数据类型、寻址技术、I/O机理

计算机组成是指**实现计算机体系结构所体现的属性**，即具体指令的实现、硬件细节

## 1.2 计算机的基本组成

### 1.2.1 冯·诺依曼计算机的特点

冯·诺依曼提出了**存储程序**的概念。

计算机有五大部件：**运算器**、**存储器**、**控制器**、**输入设备**和**输出设备**

指令和数据以**同等**地位存于存储器，可以按地址寻访

指令和数据均用**二进制码**表示

指令由**操作码**和**地址码**组成

指令在存储器内按**顺序**存放

机器以**运算器**为中心

核心特征是**存储程序**

### 1.2.2 计算机的硬件框图

![image-20200304122052042](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200304122052042.png)

![image-20200304122108315](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200304122108315.png)

运算器用来完成算术运算和逻辑运算

存储器用来存放数据和程序

控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果

输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式

输出设备可将机器运算结果转换为人们熟悉的信息形式

现代计算机可认为由三大部分组成：CPU、I/O设备及主存储器M.M

![image-20200305004915235](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200305004915235.png)

ALU (Arithmetic Logic Unit)叫做算术逻辑运算单元(简称算逻部件)， 用来完成算术逻辑运算。

CU (Control Unit)叫做控制单元，用来解释存储器中的指令，并发出各种操作命令来执行指令。

ALU和CU是CPU的核心部件。

### 1.2.3 计算机的工作过程

用计算机解决一个实际问题，通常包含两大过程。一个是上机前的各种准 备，再一个是上机运行

#### 1.2.3.1 上机前的准备

在上机解题前，先由人工完成一些必要的准备工作：建立数学模型、确定 计算方法、编制解题程序

#### 1.2.3.2 计算机的解题过程

运算器包括三个寄存器(现代计算机内部往往设有通用寄存器组)和一个算逻电路 ALU。

其中 ACC (Accumulator)为累加器，MQ (Multiplier-Quotient Register)为乘商寄存器，X为操作数寄存器。

![image-20200306085509841](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200306085509841.png)

运算器可将运算结果从 ACC送至存储器中的MDR；而存储器的操作数也可从它的MDR送至运算器 中的ACC、MQ或X

加法操作过程：

[M]→X

[ACC] + [X]→ACC

减法操作过程：

[M]→X

[ACC] - [X]→ACC

乘法操作过程：

[M]→MQ

[ACC]→X

0→ACC

[X] * [MQ]→ACC//MQ

除法操作过程：

[M]→X

[ACC] / [X]→MQ

余数 R → ACC

主存储器（简称主存或内存）包括存储体、各种逻辑部件及控制电路等

存储体由许多存储单元组成，每个存储单元又包含若干个存储元件

每个存储元件能寄存一位二进制代码“0”或“1”

一个存储单元可存储一串二进制代码，称这串二进制代码为一个存储字，这串二进制代码的个数叫作存储字长

存放在存储器中的数据按照地址访问

MAR （Memory Adress Register）是存储器地址寄存器，用来存放欲访问的存储单元的地址，其位数对应存储单元的个数

MDR （Memory Data Register）是存储器数据寄存器，用来存放从存储体某单元取出的代码或者准备往某存储单元存入的 代码，其位数与存储字长相等。

完成一条指令操作需要三个阶段：取指、分析和执行

控制器由程序计数器PC （Program Counter），指令寄存器IR （Instruction Register）以及控制单元CU几部分组成

PC用来存放当前欲执行指令的地址

IR用来存放当前的指令

IR的内容来自主存的MDR

取指过程：PC→MAR→M→MDR→IR，(PC) + 1→PC

分析过程：OP(IR)→CU

## 1.3 计算机硬件的主要技术指标

### 1.3.1 机器字长

机器字长是指CPU 一次能处理数据的位数，与CPU中的寄存器位数有关

### 1.3.2 存储容量

存储器的容量应该包括主存容量和辅存容量。 

存储容量=存储单元个数×存储字长

### 1.3.3 运算速度 

主频

核数、每个核的线程数

吉普森法：每条指令执行时间的加权平均数

MIPS （Million Instruction Per Second）即每秒执行百万条 指令

CPI （Cycle Per Instruction）即执行一条指令所需的时钟周期（主频的倒数）数

FLOPS （Floating Point Operation Per Second）即每秒浮点运算次数来衡量运算速度。

# 3 系统总线

## 3.1 总线的基本概念

计算机系统的五大部件之间的芟连方式有两种：分散连接和总线连接。 

分散连接：各部件之间通过单独的连线

总线连接：将各部件连到一组公共信息传输线上

总线连接相较于分散链接，可以减少连接线的数量

总线是连接多个部件的信息传输线，是各部件共享的传输介质

在某一时刻，只允许有一个部件向总线发送信 息，而多个部件可以同时从总线上接收相同的信息。

## 3.2 总线的分类

按数据传送方式可分为并行传输总线和串行传输总线

若按总线的使用范围划分，则又有计算机（包括外设）总线、测控总线、网络通信总线等。

### 3.2.1 片内总线

片内总线是指芯片内部的总线

### 3.2.2 系统总线

系统总线是指CPU、主存、I/O （通过I/O接口）各大部件之间的信息传 输线

按系统传输信息的不同，系统总线又可分为三类：数据总线，地址总线和控制总线

#### 3.2.2.1 数据总线

数据总线用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关

数据总线的条数称为数据总线宽度，它是衡量系统性能的一个重要参数

#### 3.2.2.2 地址总线

地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址。

地址总线上的代码是用来指明CPU欲访问的存储单元或I/O 端口的地址，它是单向传输的。

#### 3.2.2.3 控制总线

控制总线是用来发出各种控制信号的传输线

对任一控制线而言，它的传输只能是单向的

控制信号既有岀，又有入

控制总线通常用于CPU发出存储器读/写命令、向CPU发出中断请求、总线请求、时钟

### 3.2.3 通信总线

通信总线用于计算机系统之间或计算机系统与其他系统（如控制仪表、移 动通讯等）之间的通信。

## 3.3 总线特性及性能指标

### 3.3.1 总线特性

机械特性是指总线在机械连接方式上的一些性能，如几何尺寸、形状、引脚的个数以及排列的顺序

电气特性是指总线的每一根传输线上信号的传递方向和有效的电平范围

功能特性是指总线中每根传输线的功能，如地址、数据、控制

时间特性是指总线中的信号的时序关系

### 3.3.2 总线性能指标

总线宽度：它是指数据总线的根数

标准传输率（总线带宽）：即在总线上每秒能传输的最大字节量

时钟同步/异步：同步、不同步

总线复用：地址线与数据线复用，可以减少总线中信号线的数量

信号线数：即地址总线、数据总线和控制总线三种总线数的总和

总线控制方式：包站并发工作、自动配置、仲裁方式、逻辑方式、计数方式等

其他指标：如负载能力问题

### 3.3.3 总线标准

## 3.4 总线结构

### 3.4.1 单总线结构

单总线结构将CPU、主存、I/O设备（通过I/O接 口）都挂在一组总线上

单总线结构不允许两个以上的部件在同一时刻向总线传输信息

### 3.4.2 多总线结构

双总线结构的特点是将速度较低的I/O设备从单总线上分离出来，形成主存总线与I/O总线分开的结构。

三总线结构包含主存总线、I/O 总线、DMA 总线

### 3.4.3 总线结构举例

## 3.5 总线控制

### 3.5.1 总线判优控制

总线上所连接的各类设备，按其对总线有无控制功能可分为主设备和从设备两种。

主设备对总线有控制权，从设备只能响应从主设备发来的总线命令。 

若多个主设备同时要使用总线 时，就宙总线控制器的判优、仲裁逻辑按一定的优先等级顺序，确定哪个主设 备能使用总线

总线判优控制可分集中式和分布式两种，前者将控制逻辑集中在一处（如 在CPU中），后者将控制逻辑分散在与总线连接的各个部件或设备上。

常见的集中控制有三种优先权仲裁方式：链式査询、计数器定时查询、独立请求方式

在查询链中，离总线控制部件最近的设备具有 最高的优先级。

链式査询的特点是：只需很少几根线就能按一定优先次序实现 总线控制，并且很容易扩充设备，但对电路故障很敏感。

计数器定时查询：计数可以从“0”开始， 此时设备的优先次序是固定的；计数也可以从终止点开始，即是一种循环方法， 此时设备使用总线的优先级相等；

独立请求方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），但控制线数量多，总线控制更复杂。

链式查询中仅用两根线确定总线使用权属于哪个设备，在计数查询中大致用$\log_2 n$根线，其中$n$是允许接纳的最大设备数， 而独立请求方式需采用$2^n$根线。

### 3.5.2 总线通信控制

总线在完成一次传输周期时，可分为四个阶段：申请分配阶段、寻址阶段、传数阶段、结束阶段

总线通信控制常用的四种方式：同步通信 、 异步通信 、 半同步通信和分离式通信

#### 3.5.2.1 同步通信

通信双方由统一时标控制数据传送称为同步通信

时标通常由 CPU 的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步 

读命令，其传输周期为 ：

1. 主模块发地址 ；
2. 主模块发读命令
3. 从模块提供数据 
4. 主模块撤消读命令 

对于写命令 ， 其传输周期为 ：

1. 主模块发地址
2. 主模块提供数据
3. 主模块发出写命令 ， 从模块接收到命令后 ， 必须在规定时间内将数据总线上的数据写到地址总线所指明的单元中
4. 主模块撤消写命令和数据等信号 

同步通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主从模块时间配合属强制性 “ 同步 ” ， 必须在限定时间内完成规定的要求 。 并且对所有从模块都用同一限时 ， 这就势必造成对各不相同速度的部件而言 ，必须按最慢速度部件来设计公共时钟 ， 严重影响总线的工作效率 ， 也给设计带来了局限性 ， 缺乏灵活性 

同步通信一般用于总线长度较短 ， 各部件存取时间比较一致的场合

#### 3.5.2.2 异步通信

异步通信克服了同步通信的缺点 ， 允许各模块速度的不一致性 ， 给设计者充分的灵活性和选择余地 。 它没有公共的时钟标准 ， 不要求所有部件严格的统一动作时间 ， 而是采用应答方式(又称握手方式 ) ， 即当主模块发出请求(Request) 信号时 ， 一直等待从模块反馈回来"响应" ( Acknowledge) 信号后 ， 才开始通信 。 当然 ， 这就要求主从模块之间增加两条应答线(即握手交互信号线)

异步通信方式可分为不互锁 、 半互锁和全互锁三种类型

不互锁方式：主模块发出请求信号后 ， 不等待接到从模块的回答信号 ， 而是经过一段时间 ， 确认从模块已收到请求信号后 ， 便撤消其请求信号 ； 从设备接到请求信号后 ， 在条件允许时发出回答信号 ， 并且经过一段时间 ， 确认主设备已收到回答信号后 ， 自动撤消回答信号 。 可见通信双方并无互锁关系 

半互锁方式：主模块发出请求信号 ， 待接到从模块的回答信号后再撤消其请求信号 ，存在着简单的互锁关系 ； 而从模块发出回答信号后 ， 不等待主模块回答 ， 在一段时间后便撤消其回答信号 ， 无互锁关系 。

全互锁方式：主模块发出请求信号 ， 待从模块回答后再撤其请求信号 ； 从模块发出回答信号 ， 待主模块获知后 ， 再撤消其回答信号 。

#### 3.5.2.3 半同步通信

半同步通信集同步与异步通信之优点 ， 既保留了同步通信的基本特点 ， 如所有的地址、 命令 、 数据信号的发出时间 ， 都严格参照系统时钟的某个前沿开始,而接收方都采用系统时钟后沿时刻来进行判断识别 。 同时又像异步通信那样 ， 允许不同速度的模块和谐地工作 。 为此增设了一条 “ 等待 ” (WAIT) 响应信号线 

#### 3.5.2.4 分离式通信

分离式通信的特点是 ： ①各模块欲占用总线使用权都必须提出申请 ； ②在得到总线使用权后 ， 主模块在限定的时间内向对方传送信息 ， 采用同步方式传送 ， 不再等待对方的回答信号 ； ③各模块在准备数据传送的过程中都不占用总线 ， 使总线可接受其他模块的请求 ； ④总线被占用时都在作有效工作 ， 或者
通过它发命令 ， 或者通过它传送数据 ， 不存在空闲等待时间 ， 最充分地发挥了
总线的有效占用 。 从而实现了总线为多个主从模块间进行信息交叉重叠并行式
传送 。

# 4 存储器

## 4.1 概述

### 4.1.1 存储器分类

#### 4.1.1.1 按存储介质分类

按存储介质分类：半导体存储器、磁表面存储器、磁芯存储器、光盘存储器

易失性是指数据保存的环境如果不能满足某种条件，就确定会丢失

易失性存储器：半导体存储器

非易失性存储器：磁表面存储器、磁芯存储器、光盘存储器

#### 4.1.1.2 按存取方式分类

按存取方式分类：随机访问：随机存储器 RAM、只读存储器 ROM；串行访问：顺序存取存储器、直接存储存储器

#### 4.1.1.3 按在计算机中的作用分类

按在计算机中的作用分类：主存储器、辅助存储器、缓冲存储器

主存储器的主要特点是它可以和 CPU 直接交换信息

### 4.1.2 存储器的层次结构

存储器有三个主要特性：速度、容量和价格/位

![image-20200313072357076](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200313072357076.png)

存储器的层次结构主要体现在缓存一主存和主存一辅存这两个存储层次上

缓存一主存这一层次的速度接近于缓存 ， 高于主存 ；其容量和位价却接近于主存

主存一辅存这一层次 ， 从整体分析 ，廉价的辅存位价 ， 这又解决了速度 、 容量 、 成本这三者矛盾 

## 4.2 主存储器

### 4.2.1 概述

![image-20200316015609909](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200316015609909.png)

根据 MAR 中的地址访问某个存储单元时 ， 还需经过地址译码 、 驱动等电路

读出时 ， 需经过读出放大器 ， 才能将被选中单元的存储字送到 MDR 。 写入时， MDR 中的数据也必须经过写入电路才能真正写入到被选中的单元中 。

#### 4.2.1.1 主存中存储单元地址的分配

主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来 指出存储单元地址号的，根据该地址可读出一个存储字。

#### 4.2.1.2 主存的技术指标

存储容量：存放二进制代码的总位数

存储速度：存储时间：存储器的访问时间、读出时间、写入时间，存储周期：连续两次独立的存储器操作所需的最小间隔时间

存取时间比存取周期要短

存储器的带宽单位：位/秒

### 4.2.2 半导体存储芯片

#### 4.2.2.1半导体存储芯片的基本结构

半导体存储芯片内集成具有记忆功能的存储矩阵、译码驱动电路和读写电路

译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号， 

读写电路包括读出放大器和写入电路，用来完成读写操作。

存储芯片通过地址总线、数据总线和控制总线与外部连接。

地址线是单向输入的

数据线是双向的

地址线和数据线的位数共同反映存储芯片的容量

芯片容量为 $ 2 ^ n \times m $ (n 为地址线数量，m 为数据线数量)

控制线主要有读/写控制线与片选线两种

读/写控制线决定芯片进行读/写操作

片选线用来选择存储芯片

$\overline{CS},\overline{CE}$分别表示芯片选择和芯片使能，上划线表示低电平有效

一根线：$\overline{WE}$表示读/写控制线，低电平写、高电平读

两根线：$\overline{OE}$低电平读，$\overline{WE}$表示低电平写

#### 4.2.2.2 半导体储存芯片的译码驱动方式

半导体存储芯片的译码驱动方式有两种 ： 线选法和重合法

线选法的特点是用一根字选择线（ 字线），直接选中一个存储单元的各位，只适于容量不大的存储芯片。

重合法用行和列的地址决定被选单元，所需的线少。

### 4.2.3 随机存取存储器

#### 4.2.3.1 静态 RAM

使用双稳态触发器储存01

基本电路由触发器、位线、行列开关、读写放大器组成

典型芯片：Inter 2114

Inter 2114 如何实现 4 位读写？

将 1k * 4 位分为 64 * 64，并分为 16列 * 64行 的 4 组。用 6 位行的地址和 4 位列地址可以输出每一组的一个单元，合在一起就算 4 位。

#### 4.2.3.2 动态 RAM

使用电容储存01

电容上的电荷一般只能维持 1~2ms，信息会自动消失，必须在 2ms 内对其所有存储单元恢复一次原状态，这个过程叫再生或刷新

常见的动态 RAM 基本单元电路有三管式和单管式两种

三管式读出与原存信息相反，写入与输入信息相同

单管式读出时会泄放电荷，必须再生

典型芯片：Inter 1103（三管）、Inter 4116（单管）

Intel 1103三管动态RAM中，每列都有一个刷新放大器用来形成再生信息。

Intel 4116单管动态RAM容量为16K*1位，但只有7位地址线，通过缓存器先后读取行地址和列地址。

4116动态RAM芯片中的读放大器的工作原理像一个撬撬板电路，其左右两侧电平相反。

动态RAM的刷新只与行地址有关

动态RAM刷新的三种方法：集中刷新、分散刷新、异步刷新

集中刷新是在规定的一个刷新周期内 ， 对全部存储单元集中一段时间逐行进行刷新

集中刷新的缺点在于出现了访存 “ 死区 ”，必须停止读 / 写操作。

集中刷新死区时间为存取周期*行数

分散刷新是指对每行存储单元的刷新分散到每个读 / 写周期内完成 。 把存取周期分成两段 ， 前半段用来读写或维持 ， 后半段用来刷新。

异步刷新是集中与分散相结合的方式，每隔一段时间刷新一行，在一个刷新周期内保证全部行背刷新。

#### 4.2.3.3 动态 RAM 与静态 RAM 的比较

集成度：DRAM比SRAM高

芯片引脚：SRAM比DRAM多

功耗：SRAM比DRAM高

价格：SRAM比DRAM高

速度：SRAM比DRAM快

通常DRAM用于主存，SRAM用于缓存

### 4.2.4 只读存储器

#### 4.2.4.1 掩膜 ROM

用行 、 列交叉处是否有耦合元件 MOS 管 ， 便可区分原存 “ 1 ” 还是存 “ 0 ” 。

用户无法改变原始状态。

#### 4.2.4.2 PROM 

PROM 是可以实现一次性编程的只读存储器

#### 4.2.4.3 EPROM 

EPROM 是一种可擦洗可编程的只读存储器

紫外线照射 ， 驱散浮动栅 

EEPROM 电可擦写

闪速存储器 ( Flash Memory）具备 RAM 的功能

主存可由RAM和ROM组成

### 4.2.5 存储器与 CPU 的连接

#### 4.2.5.1 存储容量的扩展

存储容量的扩展 ， 通常有位扩展和字扩展

位扩展是指增加存储字长

字扩展是指增加存储器字的数量

位扩展：同一类连在一起的有对应的地址线、片选线、读写信号，分开连的有数据线。

字扩展：对应的数据线连在一起，将多出来的地址线作为片选信号。

#### 4.2.5.2 存储器与 CPU 的连接

存储芯片与 CPU 芯片相连时需要注意地址线、数据线、读/写命令线、片选线的连接和合理选择存储芯片。

### 4.2.6 存储器的校验

#### 4.2.6.1 海明码的组成

编码最小距离是指在一种编码系统中 ， 任意两组合法代码之间的最少二进制位数的差异

编码最小距离 - 1 = 检错位数 + 纠错位数 且 检错位数 $\geq$ 纠错位数

$2^{检测位数}\geq 二进制代码位数 + 检测位数 + 1$

将 k 位检测位分别安插在 n + k 位代码编号的第$1,2,4,\dotsc,2^{k-1}$位上。

$g_i$ 小组独占第 $2^{i-1}$ 位

每两小组 $g_i$ 和 $g_j$ 共同占有第 $2^{i-1}+2^{j-1}$ 位

海明码采用奇偶检验、分组校验

海明码的分组是一种非划分方式

#### 4.2.6.2 海明码的纠错过程

将传送后的海明码对应的每一小组进行异或，得到检测位 $P_i$。出错误位为 $P_nP_{n-1}\dotsc P_1$所构成的二进制值。

海明码常常被用在纠错一位的场合 

### 4.2.7 提高访存速度的措施

提高提高访存速度的措施有：采用高速器件、采用层次结构、调整主存结构

#### 4.2.7.1 单体多字系统

在一个存取周期内 ， 从同一地址取岀连续的多条指令，在逐条将指令送往CPU执行。

单体多字系统优点：增大了存储器的带宽，提高了工作速度。

单体多字系统提升的前提：指令和数据在主存内必须是连续存放的

#### 4.2.7.2 多体并行系统

多体并行系统就是采用多体模块组成的存储器。

高位交叉：程序按体内地址存放 ， 一个体存满后 ， 再存入下一个体 。 显然 ， 高位地址可表示体号 。

高位交叉编址的存储器能够提高访存速度的原因是各个体分别响应不同请求源的请求，实现多体并行。

低位交叉： 程序连续存放在相邻体中 ， 显然低位地址用来表示体号 ， 高位地址为体内地址 。

#### 4.2.7.3 高性能存储芯片

同步 DRAM（SDRAM） 在系统时钟的控制下进行读出和写入，CPU 无需等待

RDRAM 主要解决存储器带宽问题

带 Cache 的 DRAM 有利于猝发式读取

## 4.3 高速缓冲存储器（Cache）

### 4.3.1 概述

#### 4.3.1.1 为什么用 Cache

CPU 和主存存在速度差异，为了避免 CPU 空等的现象，需要 Cache

#### 4.3.1.2 Cache 的工作原理

主存与缓存按块存储，块的大小相同，块内地址相同。

主存块的数量远大于Cache块的数量

命中：要访问的主存块已经调入缓存，主存块与缓存块建立了对应关系。

用标记记录与某缓存块建立了对应关系的主存块号

Cache 的命中率：CPU欲访问的信息在 Cache 中的比率

命中率与 Cache 的容量与块长有关。

一般每块可取 4~8 个字

Cache-主存系统的效率 e = $\cfrac{访问 Cache 的时间}{平均访问时间} \times 100\%$

平均访问时间 = 访问 Cache 的时间 * 命中率 + 访问主存的时间 * （1-命中率）

#### 4.3.1.3 Cache 的基本结构

Cache 由 Cache 存储体 、 地址映象变换机构 、 Cache 替换机构几大模块组成

将主存地址映射到缓存中定位称为地址映射 

将主存地址变换成缓存地址称为地址变换

当新的主存块需要调入缓存中，而它的可用位置又被占用时，需根据替换算法解决调入问题

![image-20200330231535717](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200330231535717.png)

Cache 写操作中保持与主存一致的方法有：写直达法、写回法

写直达法：写操作时既写入Cache又写入主存，写操作时间就算访问主存的时间

写直达法能随时保证主存和cache的数据始终一致，但增加了访存次数。

写回法：写操作时只写入Cache而不写入主存，写操作时间就算访问 Cache的时间

#### 4.3.1.4 Cache 的改进

改进方法：增加Cache的级数、将统一的 Cache 变成分开的
Cache

两级缓存包括片内Cache和片外Cache

分开缓存分别为指令Cache和数据Cache

### 4.3.2 Cache——主存地址映像

#### 4.3.2.1 直接映像

每个主存块只与一个缓存块相对应

优点：结构简单、速度块

缺点：不够灵活、不能充分利用存储空间、命中率低

#### 4.3.2.2 全相联映像

主存中每一字块映象到 Cache 中的任何一块位置上

主存地址高 m 为被分成两部分：低 c 位指 Cache 的字块地址，高 t 位 指组村字块标记。

判断一段主存地址是否命中的过程：先根据中间c位字段找到Cache字块，再判断标记是否等于高 t 位，最后判断有效位是否等于 1。

优点：灵活、命中率高

缺点：电路复杂、速度慢、比较次数多

比较通常采用“按内容寻址”的相联存储器来实现。

#### 4.3.2.2 组相联映像

组相联映象是对直接映象和全相联映象的一种折衷

将 Cache 分组，主存的某一字块可以按模映射到 Cache 某组的任一字块中

### 4.3.3 替换算法

当新的主存块需要调入 Cache 并且它的可用空间位置又被占满时 ， 就产生了一个替换算法 （ 策略 ） 问题 。

常用的两种算法：先进先出算法、近期最少使用算法。

#### 4.3.3.1 先进先出(FIFO)算法

缺点是可能把一些需要经常使用的程

#### 4.3.3.2 近期最少使用(LRU)算法

 LRU 算法的平均命中率比 FIFO 高

用到程序局部性原理

## 4.4 辅助存储器

### 4.4.1 概述

特点：不直接与 CPU 交换信息

磁表面存储器的主要技术指标：记录密度、存储容量、平均寻址时间、数据传输率、误码率

寻址时间分为两个部分：找道时间和等待时间

### 4.4.2 磁记录原理

磁表面存储器通过磁头和记录介质的相对运动完成读写操作 

根据写入驱动电流的不同方向 ，使磁层表面被磁化的极性方向不同 ， 以区别记录 “ 0 ” 或 “ 1 ” 

### 4.4.3 硬磁盘存储器

按磁头分类：固定磁头和移动磁头

按盘片分类：可换盘和固定盘

硬磁盘存储器是由磁盘驱动器 、 磁盘控制器和盘片组成

磁盘驱动器的主要包括主轴 、定位驱动及数据控制等

磁盘控制器是主机与磁盘驱动器之间的接口

盘片是存储信息的载体

### 4.4.4 软磁盘存储器 

软磁盘存储器的盘片是用类似塑料薄膜唱片的柔性材料制成的

软盘转速低 ， 存取速度慢

软盘都是活动头 ， 可换盘片结构

软盘磁头直接接触盘片进行读写

软盘价格便宜 ， 盘片保存方便 、使用灵活 、 具有互换性

软盘对环境的要求不苛刻

### 4.4.5 光盘存储器

第一代光存储技术采用非磁性介质，不可擦写

第一代光存储技术采用磁性介质，可擦写

# 5 输入输出系统

## 5.1 概述

### 5.1.1 输入输出系统的发展概况

#### 5.1.1.1 早期阶段

每个 I/O 设备都必须配有一套独立的逻辑电路与 CPU 相连

CPU和I/O设备串行工作，采用程序查询方式

#### 5.1.1.2 接口模块和 DMA 阶段

I/O 设备通过接口模块与主机连接 ， 计算机系统采用了总线结构 

CPU和I/O设备并行工作，采用DMA方式和中断方式

### 5.1.2 输入输出系统的组成

输入输出系统应该由 I/O 软件和 1/0 硬件两部分组成 

#### 5.1.2.1 I/O 软件

I/O 指令是机器指令的一部分

I/O 指令的命令码一般可以表述的情况有：将数据从I/O设备输入主机、将数据从主机输出至I/O设备、状态测试、形成某些操作命令

通道指令是对具有通道的 I/O 系统专门设置的指令

通道程序是由通道控制字组成

通道指令指出数组的首地址、传送字数、操作命令

#### 5.1.2.2 I/O 硬件

一般包括接口模块及I/O设备两大部分

一个通道可以和一个以上的设备控制器相连 ， 一个设备控制器又可以控制若干台同一类型的设备。

### 5.1.3 I/O 设备与主机的联系方式

#### 5.1.3.1 I/O 编制方式

对 I/O 地址码的编址可采用两种方式 ： 统一编址或不统一编址

统一编址就是将 I/O 地址看作是存储器地址的一部分

统一编址下访问 I/O 用取数、存数指令

不统一编制有专门的 I/O 指令

#### 5.1.3.2 设备寻址

用设备选择电路识别是否被选中

#### 5.1.3.3 传送方式

数据的传送方式包括串行和并行。

#### 5.1.3.4 联络方式

 按 I/O 设备工作速度的不同 ， 可分为三种联络方式：立即响应方式、 异步工作采用应答信号联络、 同步工作釆用同步时标联络

#### 5.1.3.5 I/O 与主机的连接方式

I/O 设备与主机的连接方式通常有两种 ： 辐射式和总线式

辐射式连接不便于增删设备

### 5.1.4 I/O 与主机信息传送的控制方式

#### 5.1.4.1 程序查询方式

程序查询方式是由 CPU 通过程序不断查询 I/O 设备是否已做好准备 ， 从而控制 I/O 与主机交换信息

主机和设备传送数据时，采用程序查询方式，主机与设备是串行工作的。

#### 5.1.4.2 程序中断方式

I/O 工作分为两个阶段：自身准备、与主机交换信息

CPU 和 I/O 部分的并行工作

中断向量地址是中断服务程序入口地址的地址

#### 5.1.4.3 DMA 方式

在 DMA 方式中 ， 主存与 I/O 设备之间有一条数据通路 ， 主存与 I/O 设备交换信息时 ， 无需处理中断服务程序 。 

若出现 DMA 和 CPU 同时访问主存, CPU总是将总线占有权址给 DMA, 通常把 DMA 的这种占有叫做 “ 窃取"或 “ 挪用 ” 。 窃取的时间一般为一个存储周期 ， 故又把 DMA 占用的存取周期叫做 “ 窃取周期 ” 或 “ 挪用周期 ” 。

## 5.2 外部设备

### 5.2.1 概述

外部设备大致分三类：人机交互设备、计算机信息存储设备、机—机通信设备

### 5.2.2 输入设备

#### 5.2.2.1 键盘

键盘输入信息的三个步骤：按键、判断哪个键按下、将此键翻译成 ASCII 码

#### 5.2.2.2 鼠标器

鼠标器的两种形式：机械式、光电式

### 5.2.3 输出设备

#### 5.2.3.1 显示设备

显示设备按显示内容分有字符显示器、图形显示器和图像显示器

图形显示所显示的图形又称主观图像

图像显示多显示的图像又称客观图像

#### 5.2.3.2 打印机

按印字原理划分，打印机分为打击式和非打击式

### 5.2.4 其它外部设备

A/D、D/A是模拟/数字、数字/模拟的缩写

终端由键盘和显示器组成

终端能完成显示控制与存储、键盘管理及通信控制等功能

汉字处理设备包括：汉字输入、汉字储存和汉字输出三个部分

## 5.3 I/O 接口

### 5.3.1 概述

I/O 接口通常是指主机与外部设备之间设置的一个硬件电路及其相应的软件控制

为什么要设置接口？

1. 实现设备的选择
2. 实现数据缓冲达到速度匹配
3. 实现数据串-并格式转换
4. 实现电平转换
5. 传送控制命令
6. 反映设备的状态

端口是指接口电路中的一些寄存器，若干个端口加上相应的控制逻辑才能组成接口。

### 5.3.2 接口的功能和组成

#### 5.3.2.1 总线连接方式的I/O接口电路

I/O 总线包括数据线、设备选择线、命令线和状态线

数据线通常是双向的，用于传输数据代码

设备选择线通常是单向的，用于传输设备码，也可称为地址线

命令线和状态线是单向的

#### 5.3.2.2 接口的功能和组成

接口通常有 4 个功能：选址、传送命令、传送数据、反应设备状态

选址需要设备选择电路

传送命令需要命令寄存器、命令译码器

传送数据需数据缓冲寄存器DBR

反映设备状态需要设备状态标记

反映设备工作状态的触发器有：完成触发器D、工作触发器B、中断请求触发器INTR、屏蔽触发器MASK

### 5.3.3 接口类型

按数据传送方式分类：并行接口、串行接口

按功能选择的灵活性分类：可编程接口、不可编程接口

按通用性分类：通用接口、专用接口

按数据传送的控制方式分类：中断接口、DMA 接口

## 5.4 程序查询方式

### 5.4.1 程序查询流程

当 I/O 设备较多时 ， CPU 需按各个 I/O 设备在系统中的优先级别进行逐级查询

通常要执行三条命令：测试指令、传送指令、转移指令

启动设备前的准备工作：保护寄存器原内容、设置设备于主机交换数据的计数值、设置欲传送数据在内存缓冲区的首地址

![image-20200409120454280](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200409120454280.png)

### 5.4.2 程序查询方式的接口电路

![image-20200409120723845](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200409120723845.png)

## 5.5 程序中断方式

### 5.5.1 中断的概念

计算机在执行程序的过程中 ， 当出现异常情况或特殊请求时 ， 计算机停止现行程序的运行 ， 转向对这些异常情况或特殊请求的处理 ， 处理结束后再返回到现行程序的间断处 ， 这就是 “ 中断 ”

### 5.5.2 I/O 中断的产生

计算机系统引入中断技术的原因不仅仅是为了适应 I/O 设备工作速度低的问题

### 5.5.3 程序中断方式的接口电路

#### 5.5.3.1 中断请求触发器和中断屏蔽触发器

当完成触发器D为1且中断屏蔽触发器MASK为0时，收到CPU的中断查询信号后，中断请求触发器才会被设置为1

CPU 在执行每条指令的最后时刻査询所有的设备是否有中断请求 

#### 5.5.3.2 排队器

排队的两类办法：硬件和软件

排队器的硬件办法：链式排队器

链式排队器中，任意一个中断源提出请求后，比其优先级低的中断源都会被封锁

#### 5.5.3.3 中断向量地址形成部件 （ 设备编码器 ）

寻找入口地址的两种方法：软件查表、硬件向量法

由硬件产生向量地址，再由向量地址找到入口地址

#### 5.5.3.4 程序中断方式接口电路的基本组成

中断发生时，程序计数器内容的保护和更新，是由硬件自动完成的。

### 5.5.4 I/O 中断处理过程

#### 5.5.4.1 CPU 响应中断的条件和时间

条件：允许中断触发器 EINT = 1

时间：在每条指令执行阶段的结束前

在中断响应周期，置“0”允许中断触发器是由硬件自动完成的。

#### 5.5.4.2 I/O中断处理过程

中断处理过程简单地归纳为中断请求 、 中断判优 、 中断响应 、 中断服务和中断返回五个阶段

中断方式一般用于处理随机出现的服务请求

### 5.5.5 中断服务程序流程

#### 5.5.5.1 中断服务程序的流程

一般中断服务程序的流程分四大部分 ： 保护现场 、 中断服务 、 恢复现场和中断返回 

保护程序断点和通用寄存器内容

程序断点的保护由中断隐指令完成

寄存器内容的保护由进栈指令完成

对于不同 I/O 设备具有不同内容的设备服务

通常可用取数指令或出栈指令恢复寄存器内容

中断服务程序的最后一条指令通常是一条中断返回指令

#### 5.5.5.2 单重中断和多重中断

多重中断允许级别更高的中断源中断现行的中断服务程序

中断隐指令会关中断

单重中断与多重中断的主要区别是多重中断的服务程序中要提前开中断，而单重中断的服务程序中在最后中断返回之前才能开中断。

宏观上CPU和I/O并行工作，微观上CPU中断现行程序为I/O服务

## 5.6 DMA 方式

### 5.6.1 DMA 方式的特点

#### 5.6.1.1 DMA 和程序中断两种方式的数据通路

DMA和程序中断在数据通路上的差别是：程序中断时，主存和设备交换信息需要通过 CPU，而 DMA 方式不需要。

#### 5.6.1.2 DMA 与主存交换数据的三种方式

DMA 与主存交换数据时的三种方法：停止CPU访问主存、周期挪用 （ 或周期窃取）、DMA 与 CPU 交替访问

停止 CPU 访问主存的优点是控制简单， 适用于数据传输率很高的 I/O 设备

停止 CPU 访问主存的缺点是 DMA 接口在访存时 ， CPU 基本上处于不工作状态或保持原状态，未充分发挥 CPU 对主存的利用率

周期挪用中，DMA 访问主存有三种情况：CPU 此时不访存、CPU 正在访存、CPU 和 DMA 同时请求访存

CPU 和 DMA 同时请求访存时，CPU 将总线控制权让给 DMA

DMA方式中，周期窃取是窃取一个存取周期

DMA 与 CPU 交替访问方式将 CPU 工作周期分为两个分周期，分别供 DMA 和 CPU 访存

DMA 与 CPU 交替访问方式不需要申请建立和归还总线的使用权

### 5.6.2 DMA 接口的功能和组成

#### 5.6.2.1 DMA 接口功能

有以下五项功能：

1. 向 CPU 申请 DMA 传送
2. 处理总线控制权的转交
3. 管理系统总线，控制数据传送 ；
4. 确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度 ；
5. 在数据块传送结束时 ， 给出 DMA 操作完成的信号 

#### 5.6.2.2 DMA 接口组成

最简单的 DMA 接口组成有以下几个逻辑部件：主存地址寄存器 AR、字计数器 WC、数据缓冲寄存器 BR、DMA 控制逻辑、中断机构、设备地址寄存器 DAR

AR 用于存放主存中需要交换数据的地址

WC 用于记录传送数据的总字数，通常以交换字数的补码值预置

BR 用于暂存每次传送的数据

DMA 方式的接口电路中有程序中断部件，其作用是向CPU提出传输结束

DAR 存放 I/O 设备的设备码或表示设备信息存储区的寻址信息

### 5.6.3 DMA 的工作过程

#### 5.6.3.1 DMA 传送过程

包括三个阶段：预处理、数据传送、后处理

预处理阶段，CPU 需要设定 DMA 的传送方向、设备地址、主存地址、传送字数

数据输入时，在数据传送阶段，第一步，DMA 的 BR 将从设备读入。第二步，设备向 DMA 接口发请求 DREQ。第三步，DMA 接口向 CPU 申请总线控制权 HRQ。第四步，CPU 发回 HLDA 信号，表示允许转交总线控制权。第五步， AR 送地址总线。第六步，通知设备已被授予一个 DMA 周期 DACK。第七步，将 BR 送数据总线。第八步，修改 AR 和 WC。第九步，判断传送是否结束。如果结束，将向 CPU 申请程序中断。

DMA方式是以数据块为单位传送的。

后处理需要校验正确、判断是否继续用 DMA，由中断服务程序完成。

#### 5.6.3.2 DMA 接口与系统的连接方式

DMA 接口与系统的连接方式有两种：有公共请求线请求和独立请求

#### 5.6.3.3 DMA 方式与程序中断方式的比较

从数据传送看，程序中断方式靠程序传送 ， DMA 方式靠硬件传送 

从 CPU 响应时间看 ， 程序中断方式是在一条指令执行结束时响应，而 DMA 方式可在指令周期内的任一存取周期结束时响应 

程序中断方式有处理异常事件的能力 ， DMA 方式没有这种能力

程序中断方式的中断请求用于传送数据，DMA 的中断请求用于后处理

DMA 的优先级比程序中断高 

### 5.6.4 DMA 接口的类型

#### 5.6.4.1 选择型 DMA 接口

在物理上连接多个设备，在逻辑上只允许连接一个设备

选择型 DMA 接口特别适用于数据传输率很高的设备

#### 5.6.4.2 多路型 DMA 接口

多路型 DMA 接口适合于同时为多个数据传输率不十分高的设备服务

多路型 DMA 接口分为链式多路和独立请求多路

速度高的设备优先级高

# 6 计算机的运算方法

## 6.1 无符号数和有符号数

在计算机中参与运算的数有两大类 ： 无符号数和有符号数 

### 6.1.1 无符号数

通常称寄存器的位数为机器字长

表示范围从 0 开始

### 6.1.2 有符号数

#### 6.1.2.1 机器数与真值

把符号 “ 数字化 ” 的数叫做机器数

把带 “ + ” 或 “ - ” 符号的数叫做真值

#### 6.1.2.2 原码表示法

原码表示又称作带符号的绝对值表示

用原码做加法时，却需要减法器实现

#### 6.1.2.3 补码表示法

正数相对于 “ 模 ” 的补数就是正数本身 

负数的补码为其原码除符号位外，每位求反，末位加一

$[y]_补$ 每位取反后加1，得到的是 $[-y]_补$ 

#### 6.1.2.4 反码表示法

反码中的零也有两种表示形式

小结：最高位为符号位，书写上用“，”（整数）或“.”（小数）将数值部分和符号位隔开

#### 6.1.2.5 移码表示法

补码表示很难直接判断其真值大小

 同一个真值的移码和补码差一个符号位

## 6.2 数的定点表示和浮点表示

### 6.2.1 定点表示

根据定点机小数点约定的位置，可将其分为整数定点机与小数定点机。

当小数点位于数符和第一数值位之间时 ， 机器内的数为纯小数 ； 当小数点位于数值位之后时 ， 机器内的数为纯 整数 。

### 6.2.2 浮点表示

$N=S \times r^{j}$：S 尾数，j 阶码，r 尾数的基值

#### 6.2.2.1 浮点数的表示形式

![image-20200403203355155](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200403203355155.png)

#### 6.2.2.2 浮点数的表示范围

设浮点数阶码的数值位取 m 位，尾数的数值位取 n 位。则其可以表示的最大正数为 $2^{\left(2^{m}-1\right)} \times\left(1-2^{-n}\right)$，最小正数为 $2^{-\left(2^{m}-1\right)} \times 2^{-n}$

当浮点数阶码大于最大阶码时 ， 称为 “ 上溢 ” ， 此时机器停止运算 ， 进行中断溢出处理 ； 当浮点数阶码小于最小阶码时 ， 称为 “ 下溢 ” ， 此时 “ 溢出 ” 的数绝对值很小 ，通常将尾数各位强置为零 ， 按机器零处理 ， 此时机器可以继续运行 

#### 6.2.2.3 浮点数的规格化

规格化形式：$r=2^n\to$ 尾数的最高 n 位不全为 0

规格化：$r=2^n$ 左规，尾数每左移 n 位，阶码减 1

基数r越大，可表示的浮点数的范围越大

基数r越大，浮点数的精度降低

### 6.2.3 定点数和浮点数的比较

(1)当浮点机和定点机中的数其位数相同时，浮点数的表示范围比定点 数大得多。 

⑵当浮点数为规格化数时，其精度远比定点数高。

(3) 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化， 故浮点运算步骤比定点运算步骤多，运算速度比定点低，运算线路比定点复杂。 

(4) 在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定 点数是对数值本身进行判断。

当一个浮点数尾数为0时，不论其阶码为何值；或阶码等于或小于它所能表示的最小数时，不管其尾数为何值，机器都把该浮点数当作零看待，并称之为“机器零”

## 6.3 定点运算

### 6.3.1 移位运算

#### 6.3.1.1 移位的意义

可以采用移位和加法相结合 ， 实现乘 （ 除 ）运算 

#### 6.3.1.2 算术移位规则

移位后其符号位均不变

机器数为正时 ， 不论左移或右移 ， 添补代码均为 0

负数原码移位时添 0

负数反码移位时添 1

负数补码左移添 0 右移添 1

负数的补码左移时，高位丢0，结果出错；右移时，低位丢1，影响精度。

### 6.3.2 加法与减法运算

#### 6.3.2.1  补码加减运算的基本公式

$[A]_补 + [B]_补 = [A+B]_补$

$[A-B]_补 = [A]_补 + [-B]_补$

#### 6.3.2.2 溢出判断

用一位符号位判断溢出：用符号位产生的进位与最高有效位产生的进位异或操作后，结果为 1 即溢出。

用两位符号位判断溢出：双符号位相同即未溢出。最高符号位代表真正符号

### 6.3.3 乘法运算

#### 6.3.3.1 分析笔算乘法

符号位单独处理

乘数的某一位决定是否加被乘数

多个位积一起相加

乘积的位数扩大一倍

#### 6.3.3.2 笔算乘法的改进

乘法运算可用移位和加法来实现

由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积。同时，乘数也右移一位，由次低位作新的末位，空出最髙位放部分积的最低位 

被乘数只与部分积的高位相加

需要 3 个寄存器，分别存放被乘数、乘积高位、乘积低位及乘数

#### 6.3.3.3 原码乘法

原码一位乘

乘积的符号位由两原码符号位异或运算结果决定 

乘积的数值部分由两数绝对值相乘

由移位次数控制乘法结束

#### 6.3.3.4 补码乘法

补码一位乘

乘数为正时，同原码乘，但加和移位按补码规则运算，乘积的符号自然形成

乘数为负时，乘数去掉符号位，然后计算，最后加上被乘数的相反数的补码

Booth 算法：

![image-20200413201658112](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200413201658112.png)

最后一步不移位

### 6.3.4 除法运算

#### 6.3.4.1 分析笔算除法

商符单独处理，可以异或得出

比较余数和除数的大小上商

余数不动低位补0，减右移一位的除数

#### 6.3.4.2 原码除法

约定，小数定点除法中，|被除数|<|除数|；整数定点除法中，|被除数|>|除数|

恢复余数法：加除数相反数的补，当余数为正，上商1；余数为负，恢复余数，上商0。最后余数左移。第一次上商为1则判断溢出。

加减交替法：减除数，如果余数为正，上商1，左移一位再减除数；如果余数为负，上商0，左移一位再加除数。

## 6.4 浮点四则运算

### 6.4.1 浮点加减运算

浮点数加减运算必须按以下几步进行：1.对阶；2.尾数求和；3.规格化；4.舍入；5.判断误差

对阶的目的是使两操作数的小数点位置对齐

首先要求出阶差，再按小阶向大阶看齐的原则，使阶小的尾数向右移位，每右移一位，阶码加 1，直到两数的阶码相等为止

尾数求和就是将对阶后的尾数按定点加减运算规则运算

原码规格化不论正数、负数，第一数位为1

补码规格化符号位和第一数位不同

特规定 $[-\frac{1}{2}]_补$ 不是规格化的数，$[-1]_补$ 是规格化的数

“ 0 舍 1 入 ”法：被移去的最高数值位为 0，则舍去；被移去的最高数值位为 1，则在尾数的末位加 1 

“ 恒置 1 ”法：使右移后的尾数末位恒置“ 1 ” 

 浮点机的溢出与否可由阶码的符号决定

阶码 $[j]_补=01,\times\times\times$ 为上溢；阶码 $[j]_补=10,\times\times\times$ 为下溢，按机器零处理。

### 6.4.2 浮点乘除法运算



## 6.5 算术逻辑单元

### 6.5.1 ALU 电路

![image-20200415012615399](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200415012615399.png)

ALU 是组合逻辑电路

### 6.5.2 快速进位链

#### 6.5.2.1 并行加法器

每位全加器的进位输出是高一位全加器的进位输入

进位有两部分：本地进位和传递进位

#### 6.5.2.2 串行进位链

进位链就是传送进位的电路

![image-20200415013428050](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200415013428050.png)

#### 6.5.2.3 并行进位链

并行进位链是指并行加法器中的进位信号是同时产生的，又称先行进位、跳跃进位

通常并行进位链有单重分组和双重分组两种实现方案

单重分组跳跃进位就是将 n 位全加器分成若干小组 ， 小组内的进位同时产生 ， 小组与小组之间采用串行进位

双重分组跳跃进位就是将n位全加器分若干大组，大组中又包含若干小组。每个大组中小组的最高位进位同时产生。大组与大组之间采用串行进位。

# 7 指令系统

## 7.1 机器指令

### 7.1.1 指令的一般格式

一条指令中包含的信息有操作码、地址码。

#### 7.1.1.1 操作码

操作码反映机器做什么操作

操作码的长度可以是固定的 ， 也可以是变化的

扩展操作码技术使操作码的长度随地址数的减少而增加

不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。

#### 7.1.1.2 地址码

地址码用来指出该指令的源操作数的地址、结果的地址以及下一条指令的地址。

如果地址字段均指示主存的地址，则完成一条四地址指令，共需访问4次存储器（取指令一次，取两个操作数两次，存放结果一次）。

### 7.1.2 指令字长

指令字长决定于操作码、操作数地址的长度和操作数地址的个数。

早期的计算机指令字长 、 机器字长和存储字长均相等

通常指令字长取 8 的整数倍 

## 7.2 操作数类型和操作种类

### 7.2.1 操作数类型

机器中常见的操作数类型有：地址、数字、字符、逻辑数据等。

地址可被认为是一个无符号的整数 

计算机中常见的数字有 ： 定点数 、 浮点数和十进制数

普遍采用 ASCII 存储和传送字符

### 7.2.2 数据在存储器中的存放方式

通常要求多字节的数据在存储器的存放方式能满足 “ 边界对准 ” 的要求

### 7.2.3 操作类型

#### 7.2.3.1 数据传送

数据传送包括寄存器与寄存器 、 寄存器与存储单元 、 存储单元与存储单元之间的传送

#### 7.2.3.2 算术逻辑操作

算术运算 （ 加 、 减 、 乘 、 除 、 增 1 、 减 1 、 取负数即求补 ）和逻辑运算 （ 与 、 或 、 非 、 异或 ）

#### 7.2.3.3 移位

移位可分为算术移位 、 逻辑移位和循环移位三种

#### 7.2.3.4 转移

转移指令按其转移特征又可分为无条件转移 、 条件转移 、 跳转 、 过程调用与返回 、 陷阱 （ Trap ） 等几种

#### 7.2.3.5 输入输出

输入输出指令完成从外设中的寄存器读入一个数据到 CPU 的寄存器内 ， 或将数据从 CPU 的寄存器输出至某外设的寄存器中 

## 7.3 寻址方式

### 7.3.1 指令寻址

指令寻址分为顺序寻址和跳跃寻址两种

顺序寻址可通过程序计数器 PC 加 1, 自动形成下一条指令的地址 ； 跳跃寻址则通过转移类指令实现

### 7.3.2 数据寻址

数据寻址方式种类较多 ， 在指令字中必须设一字段来指明属哪一种寻址方式 。

指令的地址码字段 ， 通常都不代表操作数的真实地址 ， 把它称作形式地址，记作A 

操作数的真实地址叫做有效地址 ， 记作 EA

立即寻址：形式地址A就是操作数，指令执行阶段不访存

直接寻址：有效地址由形式地址直接给出，执行阶段访问一次存储器

隐含寻址：操作数地址隐含在操作码中

间接寻址：有效地址由形式地址间接提供，指令阶段2次访存

寄存器寻址：有效地址即为寄存器编号

寄存器间接寻址：有效地址在寄存器中

基址寻址：有效地址为基址+形式地址，程序运行时基址不变

变址寻址：有效地址为变址+形式地址，程序运行时变址可变

相对寻址：有效地址为当期指令地址+形式地址，广泛用于转移指令

## 7.4 指令格式举例

### 7.4.1 设计指令格式应考虑的各种因素

指令系统的兼容性、操作类型、数据类型、指令格式、寻址方式、寄存器个数

## 7.5 RISC 技术

### 7.5.1 RISC 的产生和发展

复杂指令系统计算机 ， 简称 CISC

80-20规律是指典型程序中80%的语句仅仅使用处理机中20%的指令。

### 7.5.2 RISC 的主要特征

选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合

指令长度固定、指令格式种类少、寻址方式少

只有LOAD/STORE指令访存

CPU 中有多个通用寄存器

采用流水技术一个时钟周期内完成一条指令

采用组合逻辑实现控制器

### 7.5.4 RISC 和 CISC 的比较

RISC更能充分利用VLSI芯片面积

RISC更能提高计算机运算速度

RISC便于设计，可降低成本，提高可靠性

RISC不易实现指令系统兼容

# 8 CPU 的结构和功能

## 8.1 CPU 的结构

### 8.1.1 CPU 的功能

CPU 必须具有控制程序的顺序执行（称指令控制）、产生完成每条指令所需的控制命令（称按作控制）、对各种操作实施时间上的控制（称时间控制）、对数据进行算术运算和逻辑运算（数据加工）和处理中断等功能

### 8.1.2 CPU 结构框图

CPU 四大组成：ALU、寄存器、中断系统、CU

![image-20200429183914916](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200429183914916.png)

### 8.1.3 CPU 的寄存器

#### 8.1.3.1 用户可见寄存器

通用寄存器存放操作数，可作寻址所需的专用寄存器。

数据寄存器存放操作数，通过拼接可以存放双倍字长数据

地址寄存器存放地址，用于特殊的寻址方式

条件码寄存器存放条件码，可作程序分支的依据

#### 8.1.3.2 控制和状态寄存器

MAR存储器地址寄存器，用于存放将被访问的存储单元的地址；

MDR存储器数据寄存器，用于存放欲存入存储器中的数据或最近从存 储器中读出的数据；

PC程序计数器，存放现行指令的地址，通常具有计数功能。当遇到转 移类指令时，PC的值可被修改；

IR指令寄存器，存放当前欲执行的指令

控制寄存器：PC->MAR->M->MDR->IR

状态寄存器存放条件码

PSW寄存器存放程序状态字

### 8.1.4 控制单元 CU 和中断系统

CU 产生全部指令的微操作命令序列

微操作命令序列的形成方法有两种：一种是组合逻辑设计方法 ， 为硬联线逻辑；另一种是微程序设计方法 ， 为存储逻辑

## 8.2 指令周期

### 8.2.1 指令周期的基本概念

指令周期是指 CPU 从主存取出一条指令加上执行这条指令的时间

完成一条指令包括取指周期和执行周期

取值周期包括取指、分析

执行周期包括执行

含间接寻址的指令还包括间指周期，用于取操作数的有效地址

有中断请求时，则在执行周期后加入中断周期

![image-20200429193613911](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200429193613911.png)

用四个标志触发器（FE、IND、EX、INT）区分CPU的工作周期

### 8.2.2 指令周期的数据流

#### 8.2.2.1 取值周期的数据流

![image-20200429194059951](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200429194059951.png)

#### 8.2.2.2 间址周期数据流

![image-20200429194340350](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200429194340350.png)

#### 8.2.2.4 中断周期数据流

![image-20200429195754488](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200429195754488.png)

## 8.3 指令流水

并行包含同时性和并发性两个方面，前者是指两个或多个事件在同一时刻发生，后者是指两个或多个事件在同一时间段发生。

### 8.3.1 指令流水原理

将取下一条指令的操作和执行当前指令的操作同时进行，就实现了指令的二级流水

使二级流水效率加倍失败的的两个原因：1. 指令的执行时间一般大于取值时间；2. 遇到条件转移指令时，下一条指令是不可知的。

六级流水：取值、指令译码、计算操作数地址、取操作数、执行指令、写操作数

### 8.3.2 影响流水线性能的因素

影响流水线性能的因素主要反映在两方面 ： 访存冲突和相关问题 

访存冲突：取指令、取操作数和存结果都要访问存储器

解决访存冲突的三种方法：停顿、分开指令和数据存储器、指令预取

数据相关：读一写相关、写一读相关、写一写相关

数据相关的解决方法：后推法、采用旁路技术

控制相关：一条指令要等前一条 （ 或几条 ） 指令作出转移方向的决定后 ， 才能进入流水线

### 8.3.3 流水线性能

吞吐率：单位时间内流水线所完成指令或输出结果的数量

加速比：m 段的流水线速度于等功能的非流水线的速度之比

### 8.3.4 流水线的多发技术

超标量技术：每个时钟周期内可并发多条独立指令

超流水线技术：在一个时钟周期内再分段

超长指令字技术：编译时将潜在的并行操作指令合并，需要多个功能部件同时工作。

### 8.3.5 流水线结构

#### 8.3.5.1 指令流水线结构

![image-20200504211304647](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200504211304647.png)

#### 8.3.5.2 运算流水线

![image-20200504211446257](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200504211446257.png)

分段原则：每段操作时间尽量一致

## 8.4 中断系统

### 8.4.1 概述

引发中断的各种因素：人为设置、程序性事故、硬件故障、I/O设备、外部事件

### 8.4.2 中断请求标记和中断判优逻辑

#### 8.4.2.1 中断请求标记

一个请求源对应一个中断请求标记触发器，记作 INTR

多个 INTR 组成中断请求标记寄存器

INTR 可以分散在各个中断源的接口电路中，也可以集中在 CPU 的中断系统内。

#### 8.4.2.2 中断判优逻辑

任何一个中断系统 ， 在任一时刻 ， 只能响应一个中断源的请求

![image-20200504215245737](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200504215245737.png)

软件排队是通过编写查询程序实现的

### 8.4.3 中断服务程序入口地址的寻找

#### 8.4.3.1 硬件向量法

 向量地址由中断向量地址形成部件产生

由向量地址寻找中断服务程序的入口地址的两种方法：在向量地址内存放无条件转移指令、设置向量地址表

#### 8.4.3.2 软件查询法

用软件寻找中断服务程序入口地址的方法叫软件查询法

### 8.4.4 中断响应

响应中断的条件：允许中断触发器 EINT = 1

响应中断的时间：指令执行周期结束时刻

中断隐指令完成的一系列操作：保护程序断点、寻找服务程序入口地址、关中断

### 8.4.5 保护现场和恢复现场

保护现场包括程序断点和和寄存器内容

保护程序断点由中断隐指令完成

保护寄存器内容和恢复现场由中断服务程序完成

### 8.4.6 中断屏蔽技术

#### 8.4.6.1 多重中断的概念

当 CPU 正在执行某个中断服务程序时 ， 另一个中断源又提出了新的中断请求 ， 而 CPU 又响应了这新的请求 ， 暂时停止了正在运行的服务程序 ， 转去执行新的中断服务程序 ， 这就叫多重中断

#### 8.4.6.2 实现多重中断的条件

提前设置开中断指令

优先级别高的中断源有权中断优先级别低的中断源

#### 8.4.6.3 屏蔽技术

屏蔽触发器 MASK = 1 时，对应的中断源被屏蔽

将所有屏蔽触发器组合在一起 ， 便构成一个屏蔽寄存器 ， 屏蔽寄存器的内容称作屏蔽字 。

屏蔽技术可改变处理优先级，不可改变响应优先级

#### 8.4.6.4 多重中断的断点保护

对于程序断点存入“0”地址的断点保护，需要将 0 地址内容转存

# 9 控制单元的功能

## 9.1 微操作命令分析

完成一条指令分4个工作周期：取指、间址、执行、中断

### 9.1.1 取指周期

取指令的过程可归纳为以下几个操作 ：
(1) 现行指令地址送至存储器地址寄存器 ， 记作 PC→MAR ；
(2) 向主存发读命令 ， 启动主存作读操作 ， 记作 1→R ；
(3) 将 MAR (通过地址总线)所指的主存单元中的内容 ( 指令)经数据总线读至 MDR 内 ， 记作 M(MAR)→MDR
(4) 将 MDR 的内容送至 IR, 记作 MDR → IR
(5) 形成下一条指令的地址 ， 记作 ( PC) +1 → PC,

### 9.1.2 间址周期

间址周期完成取操作数有效地址的任务 ， 具体操作如下 ：
(1) 将指令的地址码部分(形式地址)送至存储器地址寄存器 ， 记作Ad(IR)→MAR
(2) 向主存发读命令 ， 启动主存作读操作 ， 记作1→R 
(3) 将 MAR (通过地址总线)所指的主存单元中的内容(有效地址)经数据总线读至 MDR 内 ， 记作 M(MAR)→MDR
(4) 将有效地址送至指令寄存器的地址字段 ， 记作 MDR→Ad(IR). 此操作在有些机器中可省略

### 9.1.3 执行周期

#### 9.1.3.1 非访存指令

CLA 清累加器 0→ACC

COM 取反 $\overline{ACC}\to ACC$

SHR 算术右移一位 L(ACC)→R(ACC)，$ACC_0\to ACC_0$

CSL 循环左移一位指令 R(ACC)→L(ACC)，$ACC_0\to ACC_n$

停机指令 STP 0→G

#### 9.1.3.2 访存指令

加法指令 ADD X

① 将指令的地址码部分送至存储器地址寄存器 ， 记作 Ad(IR)→MAR ；
② 向主存发读命令 ， 启动主存作读操作 ， 记作1→R ；
③ 将 MAR (通过地址总线)所指的主存单元中的内容(操作数)经数据总线读至 MDR 内 , 记作 M(MAR)→MDR 
④ 给 ALU 发加命令 ， 将 ACC 的内容和 MDR 的内容相加 ， 结果存于 ACC,作 (ACC) + (MDR)→ACC

存数指令 STA X

① 将指令的地址码部分送至存储器地址寄存器 ， 记作 Ad(IR) → MAR；
② 向主存发写命令 ， 启动主存作写操作 ， 记作 1→W ；
③ 将累加器内容送至 MDR, 记作 ACC→MDR ；
④ 将 MDR 的内容（通过数据总线）写入到 MAR (通过地址总线)所指的主存单元中 ， 记作 MDR→M(MAR)

 取数指令 LDA X

① 将指令的地址码部分送至存储器地址寄存器 ， 记作 Ad(IR)→MAR
② 向主存发读命令 ， 启动主存作读操作 ， 记作 1→R;
③ 将 MAR (通过地址总线)所指的主存单元中的内容(操作数)经数据总线读至 MDR 内 ， 记作 M(MAR)→MDR ；
④ 将 MDR 的内容送至 ACC, 记作 MDR → ACC

#### 9.1.3.3 转移指令

无条件转移指令 JMP X

Ad(IR)→PC

条件转移(负则转)指令 BAN X

$A_0\cdot Ad(IR) + \overline A_0 (PC)\to PC$

![image-20200506175218051](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200506175218051.png)

### 9.1.4 中断周期

(1) 将特定地址 “ 0 ” 送至存储器地址寄存器 ， 记作 0→MAR ；
(2) 向主存发写命令 ， 启动存储器作写操作 ， 记作 1→W ；
(3) 将 PC 的内容(程序断点)送至 MDR, 记作 PC→MDR ；
(4) 将 MDR 的内容(程序断点)通过数据总线写入到 MAR (通过地址总线)所指示的主存单元 ( 0 地址单元)中 ， 记作 MDR → M(MAR)
(5) 向量地址形成部件的输出送至 PC, 记作向量地址→PC, 为下一条指令周期作准备 ；
(6) 关中断 ， 将允许中断触发器清 0, 记作 0→EINT (该操作可直接由硬件线路完成 ， 参见图 8.27).
如果程序断点存入堆栈 ， 只须将上述 (1) 改为堆栈指针 SP→MAR

## 9.2 控制单元的功能

### 9.2.1 控制单元的外特性

![image-20200507114821901](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200507114821901.png)

#### 9.2.1.1 输入信号

CU 受时钟控制，一个时钟脉冲发一个操作命令或一组需同时执行的操作命令

指令寄存器存放的操作码字段与时钟配合可产生不同的控制信号

CU 有时需要依赖 CPU 的状态标志来产生控制信号

外来信号：INTR 中断请求、HRQ 总线请求

#### 9.2.1.2 输出信号

(1 ) CPU 内的控制信号 ， 主要用于 CPU 内的寄存器之间的传送和控制 ALU 实现不同的操作 。
(2) 送至控制总线的信号 ， 如命令主存或 I/O 读/写 ， 中断响应等 

### 9.2.2 控制信号举例

#### 9.2.2.1 不采用 CPU 内部总线的方式

![image-20200507171852696](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200507171852696.png)

#### 9.2.2.2 采用 CPU 内部总线的方式

![image-20200507184251773](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200507184251773.png)

### 9.2.3 多级时序系统

#### 9.2.3.1 机器周期

机器周期是所有指令执行过程中的一个基准时间

确定机器周期需要考虑：每条指令的执行步骤、每一步骤所需的时间

基准时间的确定：以完成最复杂指令功能的时间为准、以访问一次存储器的时间为基准

若指令字长=存储字长，取值周期=机器周期

#### 9.2.3.2 时钟周期

一个机器周期内可完成若干个微操作

将一个机器周期分成若干个相等的时钟周期

时钟周期是控制计算机操作的最小单位时间

用时钟周期控制产生一个或几个微操作命令

#### 9.2.3.3 多级时序系统

一个指令周期包含若干个机器周期 ， 一个机器周期又包含若干个时钟周期（节拍）

机器周期、节拍（状态）组成多级时序系统

机器的主频f越快，机器的速度也越快

在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比

机器速度不仅与主频有关，还与机器周期中所含的时钟周期（主频的倒数）数以及指令周期中所含的机器周期数有关

### 9.2.4 控制方式

产生不同微操作命令序列所用的时序控制方式

#### 9.2.4.1 同步控制方式

任一微操作均由统一基准时标的时序信号控制

采用定长的机器周期：以最长的微操作序列和最复杂的微操作作为标准，机器周期内节拍数相等

采用不定长的机器周期：机器周期内节拍数不等

采用中央控制和局部控制相结合的方法：

大部分指令安排在统一的 、 较短的机器周期内完成，称为中央控制；少数操作复杂的指令中的某些操作采用周部控制方式来完成

![image-20200508143041816](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508143041816.png)

![image-20200508143020541](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508143020541.png)

局部控制的每一个节拍的宽度与中央控制的节拍宽度相同

计算机执行乘法指令时，由于其操作较复杂，需要更多的时间，通常采用中央与局部控制相结合的控制方式。

#### 9.2.4.2 异步控制方式

无基准时标信号

无固定的周期节拍和严格的时钟同步

采用应答方式

#### 9.2.4.3 联合控制方式

同步与异步相结合

对每条指令都有的取指令操作 ， 采用同步方式控制 ； 对那些时间难以确定的微操作 ， 如 I/O 操作 ，则采用异步控制 ， 以执行部件送回的 “ 回答 ” 信号作为本次微操作的结束

#### 9.2.4.4 人工控制方式

Reset（复位）

连续和单条指令执行转换开关

符合停机开关

# 10 控制单元的设计

控制单元设计的两种主要方法包括组合逻辑设计与微程序设计。

## 10.1 组合逻辑设计

### 10.1.1 组合逻辑控制单元框图

CU 外特性

![image-20200508144121180](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508144121180.png)

### 10.1.2 微操作的节拍安排

一个机器周期包含多少节拍与这个机器周期中需要产生的控制信号的数量以及控制信号的复杂程度、控制信号之间是否能够并行有直接关系。

#### 10.1.2.1 安排微操作时序的原则

原则一：微操作的先后顺序不得随意更改

原则二：被控对象不同的微操作尽量安排在一个节拍内完成

原则三：占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序

#### 10.1.2.2 取值周期微操作的节拍安排

T0：PC→MAR；1→R 原则二

T1：M(MAR)→MDR；(PC)+1→PC 原则二

T2：MDR→IR；OP(IR)→ID 原则三

#### 10.1.2.3 间址周期微操作的节拍按排

T0：Ad(IR)→MAR；1→R

T1：M(MAR)→MDR

T2：MDR→Ad(IR)

#### 10.1.2.4 执行周期微操作的节拍安排

执行周期不同的指令所做的微操作是不一样的。

CLA

T2：0→AC

COM

T2：$\overline{AC}\to AC$

SHR

T2：L(AC)→R(AC)；AC_0→AC_0

CSL

T2：R(AC)→L(AC)；AC_0→AC_n

STP

T2：0→G

ADD X

T0：Ad(IR)→MAR；1→R

T1：M(MAR)→MDR

T2：(AC)+(MDR)→AC

STA X

T0：Ad(IR)→MAR；1→W

T1：AC→MDR

T2：MDR→M(MAR)

LDA X

T0：Ad(IR)→MAR；1→R

T1：M(MAR)→MDR

T2：MDR→AC

JMP X

T2：Ad(OR)→PC

BAN X

T2：$A_0 \cdot Ad(IR)+\overline A_0 \cdot PC \to PC$

#### 10.1.2.5 中断周期微操作的节拍安排

中断周期需要做三件事，一保存断点，二形成中断服务程序的入口地址，三关中断为保护现场做准备。

中断隐指令

T0：0→MAR；1→W；硬件关中断

T1：PC→MDR

T2：MDR→M(MAR)；向量地址→PC

### 10.1.3 组合逻辑设计步骤

列出操作时间表

![image-20200508200746639](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508200746639.png)

IND工作周期的标志设置为1表示进入到间址周期

![image-20200508200837159](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508200837159.png)

![image-20200508201120644](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508201120644.png)

写出微操作命令的最简逻辑表达式

画出微操作命令的逻辑图

![image-20200508201423058](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508201423058.png)

特点：思路清晰，简单明了；庞杂，调试困难，修改困难；速度快（RISC）

## 10.2 微程序设计

### 10.2.1 微程序设计思想的产生

将一条机器指令编写成一个微程序 ， 每一个微程序包含若干条微指令 ， 每一条微指令对应一个或几个微操作命令 。 然后把这些微程序存到一个控制存储器中 ， 用寻找用户程序机器指令的办法来寻找每个微程序中的微指令

### 10.2.2 微程序控制单元框图及工作原理

#### 10.2.2.1 机器指令对应的微程序

![image-20200508202306819](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508202306819.png)

#### 10.2.2.2 微程序控制单元的基本框图

![image-20200508202435628](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508202435628.png)

控制存储器 （ 简称控存 ） 是微程序控制单元的核心部件 ， 用来存放全部微程序

CMAR 是控存地址寄存器 ， 用来存放欲读出的微指令地址 

CMDR 是控存数据寄存器 ， 用来存放从控存读出的微指谷

顺序逻辑是用来控制微指令序列的 ， 具体就是控制形成下一条微指令(即后继微指令)的地址

微指令共分两个字段 ， 一个为操作控制字段 ，该字段发出各种控制信号 ； 另一个为顺序控制字段 ， 它可指出下条微指令的地址(简称下地址 ) ， 以控制微指令序列的执行顺序 

#### 10.2.2.3 工作原理

取指阶段 执行取值微程序

M→CMAR
CM(CMAR)→CMDR
由CMDR发命令
形成下一条微指令地址 M+1
Ad(CMDR)→CMAR
CM(CMAR)→CMDR
由CMDR发命令
形成下条微指令地址 M+2
Ad(CMDR)→CMAR
CM(CMAR)→CMDR
由CMDR发命令

执行阶段 执行LDA微程序

OP（IR）→微地址形成部件→CMAR
CM（ CMAR ）→CMDR
由CMDR发命令
Ad（CMDR）→CMAR
CM（CMAR）→CMDR
由CMDR发命令
Ad（CMDR）→CMAR
CM（CMAR）→CMDR
由CMDR发命令
Ad（CMDR）→CMAR

在微程序控制器中，控制部件向执行部件发出的某个控制信号称为微命令

全部微指令存在CM中，程序执行过程中只需读出

关键：微指令的操作控制字段如何形成微操作命令；微指令的后续地址如何形成

### 10.2.3 微指令的编码方式

#### 10.2.3.1 直接编码（直接控制）方式

在微指令的操作控制字段中，每一位代表一个微操作命令

某位为 1 表示该控制信号有效

![image-20200508204845256](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508204845256.png)

速度最快、含义清晰 ， 但由于机器中微命令甚多 ， 可能使微指令操作控制字段达几百位 ， 造成控存容量极夬

#### 10.2.3.2 字段直接编码方式

将微指令的控制字段分成若干段，每段经译码后发出控制信号

![image-20200508205029467](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508205029467.png)

每个字段中的命令是互斥的

缩短了微指令字长，增加了译码时间

#### 10.2.3.3 字段间接编码方式

![image-20200508205149241](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508205149241.png)

#### 10.2.3.3 混合编码

直接编码和字段编码混合使用

### 10.2.4 微指令序列地址的形成

直接由微指令的下地址字段指出

根据机器指令的操作码形成

增量计数器 (CMAR)+1→CMAR

分支转移

![image-20200508205557854](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508205557854.png)

通过测试网络

![image-20200508205644002](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508205644002.png)

由硬件产生微程序入口地址

后继微指令地址形成方式原理图

![image-20200508205829140](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508205829140.png)

### 10.2.5 微指令格式

水平型微指令：一次能定义并执行多个并行操作

垂直型微指令：类似机器指令操作码的方式，由微操作码字段规定微指令的功能

两种微指令格式的比较

（ 1 ）水平型微指令比垂直型微指令并行操作能力强 ， 效率高 ， 灵活性强 。
（ 2 ）水平型微指令执行一条机器指令所需的微指令数目少 ， 因此速度比
垂直型微指令快 。
（ 3 ）水平型微指令用较短的微程序结构换取较长的微指令结构 ， 垂直型微指令正相反 ， 它以较长的微程序结构换取较短的微指令结构。
（ 4 ） 水平型微指令与机器指令差别较大 ， 垂直型微指令与机器指令相似。

### 10.2.6 静态微程序设计和动态微程序设计

静态：微程序无须改变，采用ROM

动态：通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM

### 10.2.7 毫微程序设计

#### 10.2.7.1 毫微程序设计的基本概念

微程序设计：用微程序解释机器指令

毫微程序设计：用毫微程序解释微指令

毫微指令与微指令的关系好比微指令与机器指令的关系

#### 10.2.7.2 毫微程序控制存储器的基本组成

![image-20200508232704279](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508232704279.png)

微指令是用来解释机器指令的；毫微指令是用来解释微指令的。

### 10.2.8 串行微程序控制和并行微程序控制

完成一条微指令也分两个阶段：取微指令和执行微指令

![image-20200508233250032](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Note.assets/image-20200508233250032.png)

### 10.2.9 微程序设计举例

写出对应机器指令的微操作及节拍安排

确定微指令格式

编写微指令码点