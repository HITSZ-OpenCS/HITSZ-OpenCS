---
title: 6——子程序结构
top: false
cover: false
toc: true
mathjax: true
date: 2021-01-05 15:47:52
password:
summary:
tags: "汇编"
categories: "汇编复习简纲"
---

# 第六讲 子程序结构

## 一 子程序定义

子程序定义由伪指令 `PROC` 和 `ENDP` 实现，基本格式如下

```assembly
processName proc [near|far]
	...
	ret
processName endp
```

* `NEAR` 属性：该子程序仅可被相同代码段的其他程序调用
* `FAR` 属性：可以被相同代码段或不同代码段的程序调用

## 二 子程序的调用与返回

子程序调用指令首先将子程序返回地址压入栈中，随后转移到子程序的入口地址执行子程序，分为段内调用和段外调用。子程序返回指令则将压入栈中的返回地址弹出到 IP 地址或 CS：IP中，随后正常执行。

子程序调用，其指令格式为 `call near|far ptr processName`

* `call near ptr processName`

    1、（ip）入栈

    2、（ip）<-offset processName

* `call far ptr processName`

    1、（cs、ip）入栈

    2、（cs、ip）<-（seg processName、offset processName）

子程序返回，其指令格式为`ret [val]`

* 段内返回

    1、（ip）<-（sp+1，sp）

    2、（sp）<-（sp）+2+val

* 段间返回

    1、（ip）<-（sp+1，sp）

    2、（sp）<-（sp）+2

    3、（cs）<-（sp+1，sp）

    4、（sp）<-（sp）+2+val

需要注意寄存器的保护工作，存在**堆栈保护**和**内存保护**两种保护方式，同时，保护工作既可以在主程序中，也可以在子程序中，但需在同一部分实现。

## 三 子程序设计方法

子程序位置：可以在 `mov ah 4ch//int 21h` 之后，或者是在主程序开始位置 `start` 之前，不可以出现在主程序中间位置。

子程序说明：子程序前关于下列属性的说明：子程序名、子程序功能、入口参数、出口参数、受影响寄存器

子程序传参：四种传参方式：寄存器法、变量传递法、堆栈法、参数地址指针法

* 寄存器法：约定特定的寄存器中存储入口、出口参数
* 变量传递法：使用变量名来传递参数
* 堆栈法：将入口、出口参数放入栈中（涉及到 sp、bp 的使用）
* 参数地址指针法：将参数地址通过寄存器传入子程序中

## 四 子程序嵌套与递归

需注意嵌套深度需在栈空间内以及递归终止条件

## 五 子程序的连接

大型应用程序开发过程中采用模块化的开发方式，各模块之间存在相互调用，一个模块会调用另一个模块的标识符（变量、标号、过程名等）

标识符分为两种，在本模块内使用的称为局部标识符，在一个模块定义，在另一个模块引用的称为外部标识符。

模块连接方法：

* `include filename.asm` 伪指令

    该指令负责将独立编制好的 .asm 文件在汇编时简单拼接在一起，其实质是在 `include filename.asm` 指令位置嵌入 filename.asm 文件文本，被包含文件无法单独汇编，且存在标识符冲突问题。

* 使用 `link` masm 指令进行连接

    在 dos 系统下，使用 `link fn1.obj fn2.obj ...` 指令可以将多个 .obj 文件连接在一起。要求各源程序均能单独汇编（存在必备的段），模块中需使用 `extrn` 和 `public` 标号，且两个标号需放在所有段之前。

共用标号的声明：

* `public 标识符[,标识符]`

    表示将本模块中的标识符进行共享

* `extrn 标识符:类型 [,标识符:类型]`

    类型是 byte/word/dword 或 near/far，在一个源程序中 `public` 和 `extrn` 可以拥有多条