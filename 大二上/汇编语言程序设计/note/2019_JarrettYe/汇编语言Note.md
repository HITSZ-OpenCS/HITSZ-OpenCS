食用方法：[【Anki 牌组+Markdown笔记分享】汇编语言]( https://zhuanlan.zhihu.com/p/94724167)

# 第一章 基础知识

## 1.1 进位计数制与不同基数的数之间的转换

### 1.1.1 二进制数

二进制的基数为 2，即数码的个数为 2 ，只有 0 和 1，并遵循逢二进一的规则。

十进制数 D，二进制数 B，八进制 O，十六进制 H。

### 1.1.2 二进制数和十进制之间的转换

二进制转十进制：各位二进制数码乘以其对应的权之和

十进制转二进制：整数部分连除 2，得到的余数是从低位到高位的二进制数码，小数部分连乘 2，每次整数位归零，得到的整数位是从高位到低位的二进制数码。

### 1.1.3 十六进制数及其与二进制、十进制数之间的转换

十六进制的数码：0123456789ABCDEF

十六进制和二进制转换：二进制从低位到高位每 4 位转换为一个十六进制数

十进制转十六进制：连除 16 取余，连乘 16 取整。

## 1.2 二进制数和十六进制数运算

练

## 1.3 计算机中数和字符的表示

### 1.3.1 数的补码表示

最高位表示正负

负数补码为绝对值补码取反后 +1

求补运算：按位取反 +1

## 1.4 几种基本的逻辑运算

与 AND 有 0 取 0，全 1 取 1

或 OR 有 1 取 1，全 0 取 0

非 NOT 0 转 1，1 转 0

异或 XOR 相同取 0，相异取 1

# 第二章 IMB PC 计算机组织

## 2.1 计算机系统概述

计算机结构：中央处理机CPU 存储器M 输入/输出子系统I/O

中央处理器包括运算器和控制器

系统总线：作用：连接 CPU、存储器、I/O 设备；组成成分：数据线、地址线、控制线

## 2.2 存储器

IBM PC 的字长为 16 位

存储器以字节为单位存储信息

一个字节为 8 位

每个字节单元有一个存储器地址（无符号整数）

一个字存入存储器要占有相继的 2 个字节

存放一个字时，低位字节存入低地址，高位字节存入高地址

以低位字节的地址表示字的地址

如果 M 表示地址，则(M)表示该地址存放的内容

在 1M 字节的存储器里，每一个存储单元都有一个唯一的 20 位地址

段地址的低 4 位一定是 0（20 位中低 4 位为 0，所以可以用 16 位来存储）

每 16 个字节为一小段

段起始地址必须从任一小段的首地址开始

物理地址 = 段地址（后补 4 位 0） + 偏移地址

同一个物理地址可以用不同的段地址和偏移地址组成

逻辑地址——段地址:偏移地址

段寄存器：代码段 CS、数据段 DS、堆栈段 SS、附加段 ES

## 2.3 中央处理机

数据寄存器：

AX 累加器，用于算术、逻辑运算以及与外设传送信息

BX  基址寄存器，常用于存放存储器地址

CX 计数器，一般作为循环或串操作等指令中的隐含计数器。在位操作中，当移多位时，要用 CL 来指明移位的位数；

DX 数据寄存器，常用来存放双字数据的高16位，在进行乘、除运算时，它可作为默认的操作数参与运算，亦可存放外设端口地址

可以以字节（8 位）形式访问高位低位字节，即 AH、AL……

指针与变址寄存器：

SI 源变址寄存器：与 DS 联用可在数据段中寻址

DI 目的变址寄存器：与 ES 联用可在附加段中寻址

SP 堆栈指针寄存器：用于指示栈顶的偏移地址

BP 基址指针寄存器：可作为堆栈区的一个基地址以便访问堆栈中的其他信息

控制寄存器：

IP 指令指针寄存器：存放代码段中的偏移地址，CS:IP 确定下一条指令的物理地址

PSW 程序状态字寄存器

条件码（状态标志）：

OF 溢出标志：操作数超出机器表示范围时置 1

SF 符号标志：运算结果为负时为 1

ZF 零标志：运算结果为 0 时置 1

CF 进位标志：最高有效位有进位时置 1

AF 辅助进位标志：记录运算时第 3 位产生的进位值，有进位时置 1

PF 奇偶标志：当结果操作数中 1 的个数为偶数时置 1

控制标志：

DF 方向标志：=1 时，每次操作后使变址寄存器 SI 和 DI 减量

IF 中断标志：=1 时，允许中断

TF 陷阱标志：=1 时，处理器单步执行指令

控制信息由系统程序或用户程序根据需要用指令设置

条件码用于记录程序中运行结果的状态信息，由中央处理机根据计算结果自动设置

## 2.4 外部设备

IBM PC 机的 I/O 地址端口范围为 0000~FFFFH

## 作业：2.2、2.3、2.9

# 第三章 IBM PC 机的指令系统和寻址方式

汇编指令格式：

操作码 [操作数1 [,操作数2 [,操作数3]]] [;注释]

## 3.1 IBM PC 机的寻址方式

### 3.1.1 与数据有关的寻址方式

#### 3.1.1.1 立即寻址方式

操作数直接存放在指令中，紧跟在操作码之后

只能用于源操作数，不能用于目的操作数

第一个操作数是目的操作数

#### 3.1.1.2 寄存器寻址方式

操作数在寄存器中，指令指定寄存器号

8 位寄存器：AH、AL等

16 位寄存器：AX、BX等

#### 3.1.1.3 直接寻址方式

把操作数的偏移地址称为有效地址 EA

在指令中给出偏移地址，用[]包括

默认段地址为 DS

#### 3.1.1.4 寄存器间接寻址方式

操作数的有效地址在基址寄存器 BX、BP 或变址寄存器 SI、DI 中，而操作数则在存储器中

物理地址=段地址*16d+基址/变址

#### 3.1.1.5 寄存器相对寻址方式

操作数的有效地址是一个基址或变址寄存器的内容和指令中指定的 8 位或 16 位位移量之和

物理地址=段地址*16d+基址/变址+位移量

#### 3.1.1.6 基址变址寻址方式

操作数的有效地址是基址寄存器和变址寄存器的内容之和

当基址寄存器为 BX 时，段寄存器默认 DS

当基址寄存器为 BP 时，段寄存器默认 SS

#### 3.1.1.7 相对基址变址寻址方式

操作数的有效地址是基址寄存器和变址寄存器的内容和 8 位或 16 位位移量之和

寄存器操作数地址只能由 BX、BP、SI、DI 给出

### 3.1.2 与转移地址有关的寻址方式

#### 3.1.2.1 段内直接寻址

转向的有效地址是当前 IP 寄存器的内容和指令中指定的 8 位或 16 位位移量之和。

可用于条件转移及无条件转移指令（JMP）

用于条件转移指令时，位移量只允许 8 位（短跳）

位移量为 16 位时，符号地址前加操作符 NEAR PTR

位移量为 8 位时，符号地址前加操作符 SHORT

#### 3.1.2.2 段内间接寻址

转向有效地址是一个寄存器或是一个存储器单元的内容。

直接将求得的转移的有效地址送到 IP 寄存器

段内间接寻址转移的操作符：JMP	WORD PTR

#### 3.1.2.3 段间直接寻址

指令中直接提供了转向段地址和偏移地址

偏移地址取代 IP 寄存器的内容

段地址取得 CS 寄存器的内容

段间直接寻址转移的操作符 FAR PTR

格式：JMP FAR PTR NEXTROUTINT

#### 3.1.2.4 段间间接寻址

用存储器中的两个相继字的内容来取代 IP 和 CS 寄存器中的内容

双字操作符 DWORD PTR

## 3.2 IBM PC 机的机器语言指令概况

### 3.2.1 操作码的机器语言表示

一条指令可以由 1~7 个字节组成

指令的操作码通常用指令的第一个字节表示

### 3.2.2 寻址方式的机器语言表示

操作数的寻址方式通常用机器指令的第二个字节。

## 3.3 IBM PC 机的指令系统

### 3.3.1 数据传送指令

数据传送指令负责把数据、地址或立即数传送到寄存器或存储单元

#### 3.3.1.1 通用数据传送指令

MOV 传送

PUSH 进栈

POP 出栈

XCHG 交换

MOV	DST,SRC；执行操作：(DST)←(SRC)

MOV 指令的目的操作数不允许用立即数方式和 CS 寄存器

不允许用 MOV 指令在两个存储单元或两个段寄存器之间传送数据

PUSH	SRC；执行操作：(SP)←(SP)-2，((SP)+1,(SP))←(SRC)

POP	DST；执行操作：(DST)←((SP)+1,(SP))，(SP)←(SP)+2

堆栈的存取必须以字为单位

POP 指令不允许用 CS 寄存器

XCHG	OPR1，OPR2；执行操作：(OPR1)←→(OPR2)

XCHG 的两个操作数中必须有一个在寄存器中，不允许使用段寄存器

PUSHA：16位通用寄存器依次进栈，次序为AX、CX、DX、BX，指令执行前的SP、BP、SI、DI。指令执行后(SP)-16→(SP)仍指向栈顶。 

POPA：16位通用寄存器依次出栈，次序为DI、SI、BP、SP，指令执行前的BX、DX、CX、AX。指令执行后(SP)+16→(SP) 仍指向栈顶

#### 3.3.1.2 累加器专用传送指令

IN 输入

OUT 输出

XLAT 换码

只限于使用 AX 或 AL 传送信息

IN	AL,PORT（字节）；(AL)←(PORT)

IN	AX,PORT（字）；(AX)←(PORT+1,PORT)

IN	AL,DX（字节）；(AL)←((DX))

IN	AX,DX（字）；(AX)←((DX)+1,(DX))

OUT	PORT,AL（字节）；(PORT)←(AL)

OUT	PORT,AX（字）；(PORT+1,PORT)←(AX)

OUT	DX,AL（字节）；((DX))←(AL)

OUT	DX,AX（字）；((DX)+1,(DX))←(AX)

外部设备最多有2^16个I/O端口，端口号为0000～0FFFFH，其中前256个端口（00～0FFH）可以直接在指令中指定，这就是所谓的长格式

当端口号≥256时，只能使用短格式，此时必须先将端口号放到DX寄存器中（端口号为0000～0FFFFH），然后再用IN和OUT指令来传送信息。

XLAT	OPR；(AL)←((BX)+(AL))，将一种代码转换为另一种代码

使用前，应先建立一个字节表格，表格首地址的位移量提前存入 BX 寄存器，需要转换的代码应该相对于表格首地址的位移量也提前存放在 AL 寄存器中，表格内容则是所要换取的代码，指令执行后就可在 AL 中得到转换后的代码

#### 3.3.1.3 地址传送指令

LEA 有效地址送寄存器

LDS 指针送寄存器和 DS

LES 指针送寄存器和 ES

LEA	REG,SRC；(REG)←SRC，把源操作数的有效地址送到指定寄存器

LDS	REG,SRC；(REG)←(SRC)，(DS)←(SRC+2)，把源操作数指定的 4 个相继字节送到指令指定的寄存器及 DS 寄存器中。

LES	REG,SRC；(REG)←(SRC)，(ES)←(SRC+2)，把源操作数指定的 4 个相继字节送到指令指定的寄存器及 ES 寄存器中。

#### 3.3.1.4 标志寄存器传送指令

LAHF 标志位送 AH： (AH)←(FLAGS的低字节)

SAHF AH 送标志寄存器：(FLAGS的低字节)←(AH)

PUSHF 标志进栈：(SP)←(SP) - 2， ( (SP)+1,  (SP) )←(FLAGS)

POPF 标志出栈：(FLAGS)←((SP)+1,(SP))，(SP)←(SP) + 2

SAHF，POPF影响标志位

#### 3.3.1.5 类型转换指令

CBW：AL→AX，

若(AL)的最高有效位为0，则(AH)= 00H

(AL)的最高有效位为1，则(AH)= FFH

CWD：AX→(DX,AX)

若(AX)的最高有效位为0，则(DX)= 0000H

若(AX)的最高有效位为1，则(DX)= FFFFH

### 3.3.2 算术指令

#### 3.3.2.1 加法指令

加法指令：    ADD  DST, SRC  

执行操作：    (DST)←(SRC) + (DST)

带进位加法指令：  ADC  DST, SRC  

执行操作：    (DST)←(SRC) + (DST) + CF

加1指令：        INC  OPR  

执行操作：      (OPR)←(OPR) + 1

CF 位表示 无符号数 相加的溢出。

OF 位表示 带符号数 相加的溢出。

扩展方法：若最高位为0，则用0扩展，若最高位为1，则用1扩展。

#### 3.3.2.2 减法指令

减法指令：       SUB  DST, SRC  

执行操作：       (DST)←(DST) - (SRC)

带借位减法指令：   SBB  DST, SRC  

执行操作：               (DST)←(DST) - (SRC) - CF

减1指令：         DEC  OPR  

执行操作：       (OPR)←(OPR) - 1

求补指令：       NEG  OPR  

执行操作：       (OPR)←0FFFFH - (OPR)+1

比较指令：       CMP  OPR1, OPR2 

执行操作：      (OPR1) - (OPR2)，不保存结果，只是根据结果设置  标志位。

CF 位表示 无符号数 减法的溢出

CF 是被减数的最高有效位向高位的借位值。

OF 位表示 带符号数 减法的溢出

若两个数的符号相反，而结果的符号与减数相同则 OF= 1

NEG 指令对CF/OF的影响：

操作数为 0 时，CF = 0

当字节运算时对 -128 求补以及字运算时对 -32768 求补时，OF = 1

#### 3.3.2.3 乘法指令

无符号数乘法指令：MUL  SRC

带符号数乘法指令：IMUL  SRC

字节操作数  (AX)←(AL) * (SRC)

字操作数      (DX, AX)←(AX) * (SRC)

源操作数可以使用除立即数方式以外的任一种寻址方式 

MUL乘积的高一半为零时，CF=OF=0，否则为1

IMUL乘积的高一半是低一半的符号扩展时，CF=OF=0，否则为1

#### 3.3.2.4 除法指令

无符号数除法指令：   DIV  SRC

带符号数除法指令：   IDIV  SRC

字节操作：  (AL)←(AX) / (SRC) 的商， (AH)←(AX) / (SRC) 的余数

​                                      (AH)←(AX) / (SRC) 的余数

字操作：      (AX)←(DX, AX) / (SRC) 的商， (DX)←(DX, AX) / (SRC) 的余数

​                                      (DX)←(DX, AX) / (SRC) 的余数

#### 3.3.2.5 十进制调整指令

略

### 3.3.3 逻辑指令

#### 3.3.3.1 逻辑运算指令

AND DST,SRC	逻辑与

OR DST,SRC	逻辑或

NOT OPR	逻辑非

XOR DST,SRC	逻辑异或

TEST OPR1,OPR2	测试，相当于逻辑与，但是不把结果存到目的操作数

#### 3.3.3.2 位移指令

逻辑左移  SHL  OPR, CNT

逻辑右移  SHR  OPR, CNT

算术左移  SAL  OPR, CNT（同逻辑左移）

算术右移  SAR  OPR, CNT

循环左移  ROL  OPR, CNT

循环右移  ROR  OPR, CNT

带进位循环左移  RCL  OPR, CNT

带进位循环右移  RCR  OPR, CNT

### 3.3.4 串处理指令

串传送：MOVS

存入串：STOS 

取出串：LODS

串比较：CMPS

串扫描：SCAS      

#### 3.3.4.1 与 REP 配合工作的 MOVS,STOS和LODS指令

REP	重复串操作直到 (CX)=0 为止

格式：REP MOVS/LODS/STOS

MOVS	DST,SRC（DST及SRC只提供给汇编程序作类型检测用，实际上寻址方式是隐含的）

MOVSB/MOVSW分别指定了字节和字

操作：

((DI))←((SI))

字节操作：(SI)←(SI)±1,(DI)←(DI)±1（DF=0时用+，DF=1时用-）

字操作：(SI)←(SI)±2,(DI)←(DI)±2（DF=0时用+，DF=1时用-）

执行指令前，应该做好以下准备工作：

1. 把存放于数据段中的源串首地址（如反向传送则应是末地址）放入 Sl 寄存器中
2. 把将要存放数据串的附加段中的目的串首地址（或反同传送时的末地址）放入 Dl 寄存器中 
3. 把数据串长度放入 CX 寄存器 
4. 建立方向标志

CLD：使DF=0，地址自动增量

STD：使DF=1，地址自动减量

STOS	DST

STOSB/STOSW

字节操作：((DI))←(AL),(DI)←(DI)±1

字操作：((DI))←(AX),(DI)←(DI)±2

STOS 指令在初始化某一缓冲区时很有用

LODS	SRC

字节操作：(AL)←((SI)),(SI)←(SI)±1

字操作：(AX)←((SI)),(SI)←(SI)±2

#### 3.3.4.2 与 REPE/REPZ 和 REPNE/REPNZ 联合工作的 CMPS 和 SCAS 指令

REPE/REPZ	当相等/为零时重复串操作

格式：REPE/REPZ	CMPS/SCAS

操作：

1. 如果(CX)=0或ZF=0时退出，否则继续执行

2. (CX)←(CX)-1

3. 执行其后的串指令

4. 重复 1~3

REPNE/REPNZ	当不相等/不为零时重复串操作

CMPS 串比较指令

1. ((SI))-((DI))

2. (SI)←(SI)±1,(DI)←(DI)±1

SCAS 串扫描

字节：(AL)-((DI)),(DI)←(DI) ±1

字：(AX)-((DI)),(DI)←(DI) ±2

### 3.3.5 控制转移指令

#### 3.3.5.1 无条件转移指令

JMP	SHORT OPR

(IP)←(IP)+8位位移量

JMP	NEAR PTR OPR

(IP)←(IP)+16位位移量

JMP	WORD PTR OPR

(IP)←(EA)

JMP	FAR PTR OPR

(IP)←OPR 的段内偏移地址

(CS)←OPR 所在段的段地址

JMP	DWORD PTR OPR

(IP)←(EA)

(CS)←(EA+2)

#### 3.3.5.2 条件转移指令

JZ/JE	结果为零(或相等)则转移

JNZ/JNE	结果不为零(或不相等)则转移

JS	结果为负则转移

JNS	结果为正则转移

JO	溢出则转移

JP/JPE	奇偶位为 1 则转移

JB/JNAE/JC	CF = 1 则转移

JCXZ     (CX)=0 则转移

#### 3.3.5.3 循环指令

LOOP	OPR

条件：(CX)≠0

LOOPZ/LOOPE	OPR

条件：ZF=1且(CX)≠0

LOOPNZ/LOOPNE	OPR

条件：ZF=0且(CX)≠0

步骤：

1. (CX)←(CX)-1
2. 检测是否满足条件，满足则修改 IP

OPR 是一个表示转向地址的标号

#### 3.3.5.4 子程序

CALL 调用

RET 返回

格式：CALL DST

执行的操作：

段内间接调用：

(SP)←(SP)-2

((SP)+1,(SP))←(IP)

(IP)←(EA)

段间间接调用：

(SP)←(SP)-2

((SP)+1,(SP))←(CS)

(SP)←(SP)-2

((SP)+1,(SP))←(IP)

(IP)←(EA)

(CS)←(EA+2)

带立即数返回

RET EXP 会将 EXP 表示的位移量加到(SP)上

#### 3.3.5.5 中断

### 3.3.6 处理机控制指令

#### 3.3.6.1 标志处理指令

CLC  进位位置0指令                     ；CF ← 0

STC  进位位置1指令                     ；CF ← 1

CMC  进位位求反指令                   ；CF ← Not(CF)

CLD  方向标志位置0指令             ；DF ← 0

STD  方向标志位置1指令             ；DF ← 1

CLI  中断标志位置0指令             ；IF ← 0 

STI  中断标志位置1指令             ；IF ← 1

#### 3.3.6.2 其他处理机控制指令

NOP：空操作指令，不执行任何操作，但占用一个字节存储单元，空耗一个指令执行周期，常用于程序调试

HLT：暂停指令，在等待中断信号时，该指令使CPU处于暂停工作状态，CS:IP指向下一条待执行的指令。当产生了中断信号，CPU把CS和IP压栈，并转入中断处理程序。在中断处理程序执行完后，中断返回指令IRET弹出IP和CS，并唤醒CPU执行下条指令。

# 第四章 汇编语言程序格式

## 4.1 汇编程序功能

用编辑程序建立 ASM（汇编） 源文件

用 ASM 程序把 ASM 文件转换成 OBJ 文件

用 LINK 程序把 OBJ 文件转换成 EXE 文件

用 DOS 命令直接键入文件名就可执行该程序

汇编程序的主要功能是

1. 检查源程序
2. 测出源程序中的语法错误，并给出出错信息
3. 产生源程序的目标程序，并给出列表文件
4. 展开宏指令

## 4.2 伪操作

伪操作又称伪指令，是在汇编程序对源程序汇编期间由汇编程序处理的操作

### 4.2.1 数据定义及存储器分配伪操作

格式：[Variable] Mnemonic	Operand,…,Operand

DB 定义字节

DW 定义字

DD 定义双字，存地址时，第一个字为偏移地址，第二个字为段地址

DQ 定义四个字

DT 定义十个字节

这些伪操作可以把其后跟着的数据存入指定的存储单元，或只分配存储器空间。

repeat_count DUP(operand,...,operand) 可以复制操作数

? 表示空位，占有空间但是不存放内容。

用 type PRT(属性操作符) Variable 来指定操作数的类型属性，优先于隐含的类型属性

除了属性操作符，可以用 LABEL 伪操作来定义，格式：name LABEL type

类型可以是 BYTE 字节 WORD 字 DWORD 双字

### 4.2.2 表达式赋值伪操作 EQU

用赋值伪操作给表达式赋予一个名字

Expression_name	EQU	Expression

此后可以用表达式名来代替表达式

如果 EQU 语句的表达式中有变量或标号的表达式，则在该语句前给出它们的定义

EQU 伪操作与 = 伪操作的区别是，前者不允许重复定义，而后者允许。

### 4.2.3 段定义伪操作

segment name	SEGMENT

...

segment name ENDS

还需要用 ASSUME 伪操作来明确段和段寄存器的关系

ASSUME register_name:segment_name,register_name:segment_name

ASSUME	NOTHING 可以取消前面由 ASSUME 所指定的段寄存器

ASSUME 伪操作只是指定某个段分配给哪一个段寄存器，并不能把段地址装入段寄存器中

在程序的代码段开始处就应该先进行DS、ES、SS段基址的装填，否则无法正确对数据进行寻址操作。CS由系统自动装填。

定位类型

PARA 指定段的起始地址必须从小段边界开始，即段地址的最低十六进制数位为 0

BYTE 该段可以从任何地址开始

WORD 该段必须从字的边界开始，即段地址必须为偶数

PAGE 该段必须从页的边界开始，即段地址的最低两个16进制数位必须为 0

组合类型

PUBLIC 该段连接时将与有相同名字的其他分段连接在一起

COMMON 该段在连接时与其他同名分段有相同的起始地址，所以会产生覆盖

COMMON 的连接长度是各分段中的最大长度

STACK 指定该段在运行时为堆栈段的一部分

MEMORY 指定该段将分配在所有其他连接在一起的段的前面（高地址）

类别（'class'） 连接时用于组成段组的名字

grpname GROUP segname[,segname…]

可以允许用户自行指定段组，这样程序可以用同一个段寄存器访问定义在不同段中的变量

### 4.2.4 程序开始和结束伪操作

在程序的开始可以用 NAME 或 TITLE 为模块取名字

NAME module_name

TITLE text（不加引号的字符串）

如果程序中没有使用 NAME 伪操作，则汇编程序将用 text 中的前六个字符作为模块名

text 最多可以有 60 个字符

如果程序中既无 NAME 又无 TITLE 伪操作，则将用源文件名作为模块名

表示源程序结束的伪操作的格式为：END [label]

label 指示程序开始执行的起始地址，如果多个程序模块相连接，则只有主程序使用标号，其他子程序模块只用END而不必指定标号。

### 4.2.5 对准伪操作

EVEN 伪操作使下一个字节地址成为偶数

对于字数组，最好保证其从偶地址开始

ORG Constant expression 伪操作可以使下一个字节的地址成为常数表达式的值 n

在汇编程序对源程序汇编的过程中，使用地址计数器来保存当前正在汇编的指令的地址

地址计数器的值可用 $ 来表示

### 4.2.6 基数控制伪操作

汇编程序默认的数为十进制数

十六进制数的第一个字符必须是 0~9，否则前面加上数字 0

RADIX expression 可以把默认的基数改变为 2~16 内的任何基数

## 4.3 汇编语言程序格式

[name] operation operand [;comment]

操作项是一个操作码的助记符，可以是指令、伪操作或宏指令名

操作数项由一个或多个表达式组成

### 4.3.1 名字项

除数字外，所有字符都可以放在源语句的第一个位置

名字由如果用到原点(.)则必须是第一个字符

单独的“?”不能作为名字

可以用很多字符来说明名字，但只有前面的31个字符能被汇编程序所识别。

标号用来代表一条指令所在单元的地址，在代码段中定义及使用。

标号放在语句的前面，并用冒号“:”与操作项分开。

标号不是每条指令所必需的，它也可以用LABEL或EQU伪指令来定义

标号经常在转移指令或CALL指令的操作数字段出现，用以表示转向的目标地址

标号和变量都具有三种属性：段属性、偏移属性及类型属性

段属性定义标号或变量的段起始地址，此值必须在一个段寄存器中。

偏移属性是标号或变量所在的地址距段基址的偏移量。它们通常在指令中以显式方式出现，并最终能确定其有效地址EA。

标号的类型属性用来指出该标号是在本段内引用还是在其它段中引用。如在段内引用的，则称为NEAR，指针长度为2个字节；如在段外引用，则称为FAR，指针长度为4个字节。

变量的类型属性定义该变量所保留的字节数。如BYTE（1字节），WORD（2字节），DWORD（4字节），FWORD（6字节），QWORD（8字节），TBYTE（10字节）。

在同一个程序中，同样的标号或变量的定义只允许出现一次，否则汇编程序会提示出错。

### 4.3.2 操作项

操作项可以是指令、伪操作或宏指令

对于指令，汇编程序将其翻译为机器语言指令。

对于伪操作，汇编程序将根据其所要求的功能进行处理。

对于宏指令，则将根据其定义展开。 

### 4.3.3 操作数项

#### 4.3.3.1 算术操作符

算术操作符：  +、- 、*、 /、Mod

算术操作符可以用于数字表达式或地址表达式

地址+或-是有意义的，但两个地址*或/是无意义的。

#### 4.3.3.2 逻辑操作符

 AND、OR、XOR 和 NOT 

逻辑操作符是按位操作的 ，它只能用于数字表达式中

#### 4.3.3.3 关系操作符

 EQ(相等) 、 NE(不等)、 LT( 小于) 、 GT( 大于 ) 、LE(小于或等于) 、 GE( 大于或等于 )

关系操作符的两个操作数必须都是数字或是同一段内的两个存储器地址

计算的结果应为逻辑值：结果为真，表示为 0FFFFH ，结果为假，则表示为 0 。 

#### 4.3.3.4 数值回送操作符

TYPE：返回变量以字节数表示的类型

DB 2

DW 4

DD 6

DQ 8

DT 10

NEAR -1

FAR -2

常数 0

LENGTH：对于变量中使用DUP的情况，返回分配给该变量的单元数，其他情况返回1.

SIZE：返回分配给该变量的字节数，等于TYPE值*LENGTH值。

OFFSET：回送变量或标号的偏移地址

SEG：回送变量或标号的段地址

#### 4.3.3.5 属性操作符

SHORT：用来修饰跳转指令中转向地址的属性，指出转向地址在下一条指令的-127~+127个字节范围之内

HIGH和LOW ：字节分离操作符。对一个数或表达式，HIGH取其高字节，LOW取其低字节。

HIGHWORD、LOWWORD：字分离操作符。对一个数或表达式，HIGHWORD取其高位字，LOWWORD取其低位字。

# 第五章 循环与分支程序设计

## 5.1  循环程序设计

### 5.1.1 循环程序的结构形式

不论何种循环结构，循环程序都由以下三个部分组成

1. 设置循环的初始状态
2. 循环体
3. 循环控制部分

### 5.1.2 循环程序设计方法

## 5.2 分支程序设计

# 第六章 子程序结构

## 6.1 子程序的设计方法

### 6.1.1 过程定义伪操作

procedure_name PROC Attribute

...

procedure_name ENDP

procedure_name 是子程序入口的符号地址

Attribute 是类型属性，可以是 NEAR 或 FAR

调用程序和过程在同一个代码段中，使用 NEAR 属性

调用程序和过程不在同一个代码段中，使用 FAR 属性

### 6.1.2 子程序的调用和返回

CALL 和 RET 指令就完成了调用和返回的功能。但是要注意 PROC 的属性和子程序运行期间的堆栈状态。

### 6.1.3 保存与恢复寄存器

要仔细考虑哪些寄存器是必循保存的，哪些是不必要或不应该保存的。一般说来，子程序中用到的寄存器是应该保存的。但是，如果使用寄存器来在主程序和
子程序之间传送参数的话，这种寄存器就不一定需要保存，特别是用来向主程序回送结果的寄存器，就更不应该因保存和恢复寄存器而破坏了应该向主程序传送的信息。

### 6.1.4 子程序的变量传送

#### 6.1.4.1 通过寄存器传送变量

子程序对带有出口参数的寄存器不能保护和恢复

对于带有入口参数的寄存器建议保护

保护方法：

PUSH AX

PUSH BX

PUSH CX

PUSH DX

...

POP DX

POP CX

POP BX

POP AX

#### 6.1.4.2 直接访问模块中的变量

主程序和子程序直接采用同一个变量名共享同一个变量，实现参数的传递。

#### 6.1.4.3 通过地址表传送参数地址

将每组数据的首地址存到 SI 中，元素个数存在  CX 中，子程序用 SI 寻址获得参数

#### 6.1.4.4 通过堆栈传送参数或参数地址

主程序将子程序的入口参数压入堆栈，子程序从堆栈中取出参数；
子程序将出口参数压入堆栈，主程序弹出堆栈取得它们。

为了避免直接对 SP 的值进行修改，可以用 BP 暂存 SP，然后用寻址方式调用参数。

#### 6.1.4.5 多个模块之间的参数传送问题

标识符有两种：
1）在本模块中定义，供本模块使用的标识符称为局部标识符；2）在一个模块中定义，而又在另一个模块中引用的标识符称为外部标识符。

PUBLIC 标识符[,标识符…]；定义标识符的模块使用

EXTRN 标识符:类型 [,标识符:类型...];调用标识符的模块使用

标识符可以是变量名、标号、过程名等

类型是 byte/word/dword 或 near/far

各模块间的public/extrn伪指令要互相配对，并且指明的类型互相一致。

模块连接方法有：1.在汇编时把各个模块连接在一起；2.LINK 连接时把各个模块连接在一起

在汇编时把各个模块连接在一起，要使用 INCLUDE 文件名。每个 INCLUDE 后面只能由一个文件名。不能有重名标号。

LINK连接各个模块时，需要用 PUBLIC 和 EXTRN 语句，放在所有段前面

### 6.2 子程序嵌套



# 第 7 章 高级汇编语言技术

## 7.1 宏汇编

### 7.1.1 宏定义、宏调用和宏展开

宏定义的格式

宏指令名 	MACRO    [形式参数表]
			．．．		; 宏体
			ENDM（和子程序不同，ENDM之前不用写宏名）

实参和形参的个数可以不等，若调用时的实参个数多于形参个数，则多余的部分被忽略；若实参个数小于形参个数，则多余的形参假定为空（NULL）。

宏调用的格式：

宏指令名 [实参表]

实参表通常与宏定义中形参表相对应。当需要使用多个实参时,各实参之间要用逗号分隔。

宏定义可以放在程序的任何地方（调用处之前），一般建议把宏定义放在程序的最前面。

宏展开：

当汇编程序扫描源程序遇到已有定义的宏调用(宏指令)时，即用相应的宏定义体取代源程序的宏指令，同时用位置匹配的实参对形参进行取代。

### 7.1.2 宏定义中的参数

宏体可以没有形参

形参可以是操作码  

形参可以是操作码的一部分，但是要用&作为分隔符

%表达式 可以在宏调用时强迫后面的表达式立即求值，并把表达式的结果作为实参替换，而不是表达式本身。

!字符 可以转义操作符，把后面的字符当成普通字符对待

### 7.1.3 LOCAL 伪操作

LOCAL伪指令的一般格式：

LOCAL  标号及变量表

各标号、变量之间均用逗号分隔

LOCAL伪操作只用在宏定义体内，且LOCAL伪指令必须紧接MACRO伪指令之后，它们中间不能有注释和分号标志。

在处理各个宏调用时，汇编程序将自动以??0000，??0001，……，??FFFF替代LOCAL从伪指令列出的各个标号或变量，从而避免多次宏调用时出现多个相同标号或出现变量重复定义的问题。

### 7.1.4 在宏定义内使用宏

宏嵌套像子程序一样包括两种情况：
其一：宏体中包括宏定义。 
其二：宏定义的宏体中包括宏调用，即在宏体中调用宏体外定义的宏指令。在这种情况下要注意，其调用的宏指令必须先行定义；

不能在源程序中直接调用内层定义的宏指令

### 7.1.5 列表伪操作

### 7.1.6 宏库的建立与调用

宏库的扩展名可以是\*.mac、\*.lib、或\*.asm。

调用插入伪指令 INCLUDE 

格式：INCLUDE  \[ 驱动器名：][目录路径]文件名.扩展名

### 7.1.7 PURGE 伪操作

删除宏库中部分宏伪指令PURGE

格式：PURGE 宏指令名

宏指令名可以与指令助记符及伪指令名同名。在此情况下，宏指令的优先级较高，同名的指令或伪指令的原有功能失效。若要恢复其原有功能，可以使用清除宏定义的伪指令。

## 7.2 重复汇编

### 7.2.1 重复伪操作

重复汇编格式：

REPT 整数表达式

​	重复体

ENDM

功能：使汇编程序对重复体作重复汇编，以整数表达式的值作为重复次数。

### 7.2.2 不定重复伪操作

IRP 伪操作

格式：

IRP    形参，＜实参表＞  

​	重复体

ENDM

功能：使汇编程序对重复体作重复汇编，每作一次汇编就依次将实参表中的一个实参取代重复体中的形参。 

IRPC伪操作
格式：

IRPC  形参，字符串
	重复体
ENDM
功能：使汇编程序对重复体作重复汇编，每作一次汇编就依次用字符串中的一个字符取代重复体中的形参。 与IRP相似，但实参必须是字符串。

# 第 8 章 输入输出程序设计

## 8.1 I/O 设备的数据传送方式

### 8.1.1 CPU 与外设

CPU与外设之间的接口信号：

数据信息、状态信息、控制信息

数据信息：这是CPU和外设之间真正要交换的信息。

状态信息：用来反映外设接口电路或外设的状态，CPU可根据这些状态信息决定对外设的操作或控制。

控制信息：用于控制输入输出设备装置的启动或停止，设备的工作方式等。

### 8.1.2 直接存储器存取方式

主机与外设之间的数据传送(控制)方式：

●直接存储器存取(DMA)方式
●程序直接控制I/O方式（查询方式）
●中断传送方式

DMA一般包括四个寄存器：控制寄存器（设置控制字：输入/输出、启动DMA等）、状态寄存器（DMAC状态）、地址寄存器（要传送数据块的首地址）、和字节计数器（要传送的数据字节数），这些寄存器在数据传送之前应该初始化。

在实现DMA传输时，由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。

## 8.2 程序直接控制 I/O 方式

### 8.2.2 I/O 命令

直接寻址：只用于寻址00H～0FFH前256个端口，操作数表示端口号。
间接寻址：可用于寻址全部64K个端口，DX寄存器的值就是端口号，对大于0FFH的端口只能采用间接寻址方式。

IN 指令可以从一个状态寄存器输入接口和外设的状态

OUT 指令可以给一个指定的 I/O 端口传送命令信息

长格式

IN/OUT AL,PORT

IN/OUT AX,PORT

短格式

IN/OUT AL,DX

IN/OUT AX,DX

## 8.3 中断传送方式

当CPU正在执行某程序时，由于外界事件的需要向CPU发出申请，CPU暂停现行程序的执行而转去处理临时发生的事件，处理完后再返回到被中断程序的断点处，继续向下执行，这个过程称为**中断**。

中断是CPU和外部设备进行I/O的有效方法。它可以避免因反复查询外部设备的状态而浪费时间，提高CPU的效率。

在中断过程中执行的事件处理程序称为**中断服务程序**

三种数据传送方式速度对比：
直接I/O<中断<DMA

### 8.3.1 中断分类

#### 8.3.1.1 软件中断

软件中断（内中断）：由程序安排的中断指令产生的中断、或CPU的某些错误结果产生的中断

   （1）中断0——除法错中断；除数为0或商超过了寄存器的范围
   （2）中断1——单步中断； TF＝1，允许单步调试
   （3）中断3——断点中断；用于断点调试（INT   3）
   （4）中断4——溢出中断；执行溢出中断指令，OF＝1时产生
   （5）用户定义的软件中断(指令中断) ：执行中断调用指令INT  n产生的 n号中断，如INT 21h

所有的内部中断都具有下述特点：
1）中断向量码或者包含在指令中，或者是预定的；
2）除单步中断外，内部中断都无法禁止；
3）除单步中断外，任何内部中断的优先级都比任何外部中断的高。

中断调用指令

INT n

n称为中断类型号，必须是0~255之间的立即数

中断返回指令

IRET

#### 8.3.1.2 硬件中断

硬件中断（外中断）：由外设控制器或协处理器引起的中断。
可屏蔽中断：可被中断允许标志IF的屏蔽。
非屏蔽中断（NMI）：为电源错、内存或I/O总线的奇偶校验等异常事件保留的中断。它不受中断允许标志IF的屏蔽。整个系统只能有一个NMI。

从外设发出的中断请求到CPU响应中断，有两个控制条件起决定作用：
1)外设的中断请求是否被屏蔽, 
2)CPU是否允许相应中断。

CLI 关中断

STI 开中断

中断屏蔽寄存器的I/O地址是21H，他的8位对应控制8个外部设备，某位0表示允许中断，1表示禁止中断。

在一次中断处理结束之前，还应给8259A的中断命令寄存器发出中断结束命令（End of Interrupt, EOI, 第5位）。

中断命令寄存器的I/O端口地址为20H。

当EOI=1时，当前正在处理的中断请求被清除。所以在中断处理完成后，必须把EOI为置1。

L2~L0指定IR0-IR7中具有最低优先级的中断请求，第6、7位控制IR0-IR7中断优先级的顺序。

中断优先级：

除法错、INT、INTO

NMI

INTR

单步中断

### 8.3.2 中断向量表

中断向量表：中断服务程序的入口地址。    

8086/8088在其内存的前1K字节（地址为0000H~03FFH）建立了一个中断向量表。

表中内容分为256项，对应于类型号0~255。

每一项占用4个字节单元，用来存放相应类型的中断服务程序的入口地址。

高两个字节存放服务程序的入口地址的段地址部分。低两个字节存放偏移地址。

若中断号为N，则其中断子程序入口地址在向量表中的位置为：
IP←(N\*4+1, N\*4)
CS←(N\*4+3, N\*4+2)

### 8.3.3 中断程序设计方法

可调用DOS功能调用（21H）来存取中断向量：
设置中断向量：把由AL指定的中断类型的中断向量DS:DX放入中断向量表。

预置：AH=25H，AL=中断类型号，DS:DX=中断向量
执行：INT  21H

读取中断向量：把由AL指定的中断类型的中断向量从中断向量表中取到ES:BX。

预置：AH=35H，AL=中断类型号
执行：INT  21H
返回：ES:BX=中断向量

中断程序的编写步骤：
主程序：	

​		（1）设置中断向量
​		（2）设置 CPU 的中断允许位 IF
​		（3）设置设备的中断屏蔽位

中断处理子程序：	

​			（1）保存寄存器内容
​			（2）如允许中断嵌套，则开中断 ( STI )
​			（3）中断处理功能
​			（4）关中断（CLI）
​			（5）送中断结束命令( EOI )给中断命令寄存器
​			（6）恢复寄存器内容
​			（7）IRET 中断返回 

# 第 9 章 BIOS及DOS功能调用

## 9.1 BIOS及DOS简介

只读存储器ROM中固化有一组外部设备驱动与管理软件，组成PC机基本输入输出系统BIOS

BIOS主要包括以下一些功能：
①系统自检及初始化
②系统服务
③硬件中断处理

DOS 即磁盘操作系统，主要完成对文件、设备、内存的管理

DOS 主要包括三个模块：IBMBIO.com，IBMDOS.com，COMMAND.com

IBMIO.COM是DOS在ROM BIOS的基础上开发的一组输入输出设备处理程序

IBMDOS.COM是文件管理程序和一些处理程序

COMMAND.COM是DOS的命令处理程序

在一些情况下，既能选择DOS中断也能采用BIOS中断来执行相同的任务

少数情况下，必须使用BIOS功能，没有相应的DOS功能调用

一般来说，使用DOS操作比使用相应功能的BIOS操作更简易，而且DOS对硬件的依赖性更少些。

BIOS和基本DOS的作用

用户可通过使用BIOS和DOS系统提供的这些功能模块子程序（中断子程序调用），来编制直接管理和控制计算机硬件设备的底层软件（主要是完成I/O操作）。

用户不必深入了解有关设备的电路和接口，只须遵照DOS规定的调用原则即可使用。 

用户编程原则

尽可能使用DOS的系统功能调用。
在DOS功能不能实现情况下，考虑用BIOS功能调用。
在DOS和BIOS的中断子程序不能解决问题时，使用IN/OUT指令直接控制硬件。

BIOS/DOS的每个功能都对应着一个中断服务程序
BIOS/DOS中断属于软件中断

① DOS中断：n＝ 20H～3FH
② BIOS中断：n＝5H～1FH
③ 自由中断：n＝40H～FFH（用户可自定义）

一般来说，调用DOS或BIOS功能时，有以下几个步骤：

（1）将调用参数装入指定的寄存器。

（2）如需功能调用号，把它装入AH。

（3）如需子功能调用号，把它装入AL。

（4）按中断号调用DOS或BIOS。

（5）检查返回参数是否正确。

DOS调用与BIOS调用两者的异同：

DOS功能调用在更高层次上提供了与BIOS类同的功能。

DOS调用与BIOS调用两者的区别

调用BIOS中断程序比调用DOS的复杂一些，但运行速度快，功能更强；

DOS功能调用只适用于DOS环境，而BIOS功能调用不受任何操作系统的约束；
某些功能只有BIOS具有。

## 9.2 键盘I/O

### 9.2.1 字符码与扫描码

键盘主要由3种基本类型的键组成：

字符数字键、扩展功能键、组合使用的控制键

字符数字键给计算机传送一个ASCII码字符，而扩展功能键产生一个动作，使用组合控制键能改变其他键所产生的字符码。

按键的识别采用行列扫描法，即根据对行线和列线的扫描结果来确定闭合键的位置，这个位置值称为按键的扫描码，通过数据线将8位扫描码送往主机。

当在键盘上“按下”或“放开”一个键时，如果键盘中断是允许的（8259A 21H端口的第一位等于0），就会产生一个类型9的中断，并转入到BIOS的键盘中断处理程序。

该处理程序从8255可编程外围接口芯片的输入端口读取一个字节，这个字节的低7位是按键的扫描码。最高位为0或者为1，分别表示键是“按下”状态还是“放开”状态。按下时，取得的字节称为通码，放开时取得的字节称为断码。如ESC键按下取得的通码为01H（00000001B），放开ESC键时会产生一个断码81H（10000001B）。

没有相应ASCII码的键，如Alt和功能键（F1～F10），字符码为0

还有一些非ASCII码键产生一个指定的操作，如PRTSC

转换成的字符码以及扫描码存储在BIOS数据区的键盘缓冲区KB_BUFFER中

键盘缓冲区是一个先进先出的循环队列。  

虽然缓冲区的本身长度为16个字，但出于判断“队列满”的考虑，它最多只能保存15个键盘信息。

当Buffer_Head＝Buffer_Tail时，说明缓冲区为空，表示无键盘输入。

键盘中断：09H vs. 16H?

09H：硬件中断；16H：软件中断。

BIOS的INT 09H和INT 16H中断处理程序是一对相互配合的程序，其中09H向键盘缓冲区写入，16H从键盘缓冲区读出。

处理时机不同：09H是有键按下的时候产生硬件中断并触发；16H是应用程序调用的时候起作用。

### 9.2.2 BIOS键盘中断

类型 16H 的中断提供了基本的键盘操作，它的中断处理程序包括3个不同的功能，分别根据AH寄存器中的子功能号来确定。

（1）AH=0：从键盘读字符到AX寄存器中。其中AL=字符码，AH=扫描码。

（2）AH=1：读键盘缓冲区字符到AX寄存器中，并置ZF标志位。

若ZF=0，则AL=字符码，AH=扫描码

若ZF=1，则表示缓冲区空

（3）AH=2：读取键盘状态字节。(AL=键盘状态字节）。

键盘中的控制键和双态键是非打印按键，它们是起控制或转换作用的。当使用者按下控制键或双态键时，系统要记住其所按下的按键。为此，在计算机系统中，特意安排的一个字节来标志这些按键的状态，我们称该字为键盘状态字节（KB_Flag） 。

### 9.2.3 DOS中断调用

1）单字符输入：

INT 21H的1号功能，AL=输入字符

如果程序要求能接收功能键或数字组合键必须进行两次DOS功能调用：第一次回送00
第二次回送扫描码

2）输入字符串
	INT 21H的10号功能，DS：DX=缓冲区首地址。

缓冲区的第一个字节保存最大字符数（逻辑上限是255），由用户设定，若输入的字符数大于此数，PC机会发出“嘟嘟”声，光标不再移动。

第二个字节是实际输入字符的个数。这个数据由功能10自动填入。

两个字节之后就是用户输入的字符串，以回车键结束（也会占用一个字节）。

因此缓冲区的大小应为：最大字符数（包括回车）+2

3）清除键盘缓冲区

Int 21的功能0ch能清除键盘缓冲区，然后执行在AL中指定的功能。AL中指定的功能可以是1，6，7，8或0AH。

4）检验键盘状态

INT 21H的0B号功能可以检验一个键是否被按动，如果按下一个键，则AL=0FFH，否则AL=0。无论哪种情况都将继续执行下一条语句。

## 9.3 显示器I/O

### 9.3.1 字符属性

在常用的文本显示模式下，屏幕被划分成25行，每行可显示80个字符，所以，每屏最多可显示2000(80×25)个字符。

为了便于标识屏幕上的每个显示位置，我们就用其所在行和列来表示之，并规定：屏幕的左上角坐标为(0, 0)，右下角坐标为(24, 79)。

对应显示屏幕上的每个字符，在存储器中由连续的两个字节表示，一个字节表示ASCII码，另一个字节保存字符的属性。

1、单色字符显示：对单色显示，字符的属性确定了该字符的显示方式，如字符是否闪烁、是否高亮度、是否反向显示等。    

闪烁位 7

背景位 6 5 4

亮度位 3

前景位 2 1 0

2、彩色字符显示：显示彩色字符时，属性字节可以选择显示字符的前景颜色和背景颜色。

前景颜色有16种可以选择，背景颜色有8种可以选择。

闪烁和亮度只应用于前景。

对于单色显示适配器MDA，显存的起始地址为B000:0000；对于CGA、EGA、VGA是B800:0000。

在25 X 80的文本显示方式下，屏幕可有2000个字符位置，因每个字符需要用两个字节，所以每屏显存容量需要4K

Char_Offset=Page_Offset+(row\*width+column)\*byte

byte是表示一个字符所用的字节数，这里：byte=2。

### 9.3.2 BIOS显示中断

（1）设置光标类型（1号功能）
          入口参数：AH=1（功能号），CH=光标开始行，CL=光标结束行。
         出口参数：无。根据CX给出光标的大小。
（2）设置光标位置（2号功能）
          入口参数：AH=2（功能号），BH=页号，DH=行号，DL=列号。
          出口参数：无。根据DX确定了光标位置。
（3）读当前光标位置（3号功能）
         入口参数；AH=3（功能号），BH=页号。
         出口参数：DH=行号，DL=列号，CX=光标大小。

（4）初始窗口或向上滚动（6号功能）
         入口参数：AH=6，AL=上滚行数，CX=上滚窗口左上角的行、列号。DX=上滚窗口右下角的行、列号。BH=空白行的属性。
        出口参数：无。当滚动后，底部为空白输入行。
（5）初始窗口或向下滚动（7号功能）
         入口参数：AH=7，AL=下滚行数，CX=下滚窗口左上角的行、列号。DX=下滚窗口右下角的行、列号。BH=空白行的属性。
         出口参数：无。当滚动后，顶部为空白输入行。
（6）读当前光标位置的字符与属性（8号功能）
         入口参数：AH=08H，BH=页号。
         出口参数：AL为读出的字符，AH为字符属性。
（7）在当前光标位置写字符和属性（9号功能）
         入口参数：AH=9，BH=页号，AL=字符的ASCII码，BL=字符属性，CX=写入字符重复次数。
         出口参数：无。

### 9.3.3DOS显示功能调用

显示字符串 (09H功能)
入口参数：
定义要显示的字符串，字符串尾应为‘\$’，作为结束显示的标志。
DS : DX = 字符串的首地址
功能号：AH = 09H
类型号：21H
出口参数：无
实现功能：显示字符串，遇‘\$’停止显示，光标随动。

## 9.4 串行通信口I/O

计算机与外设交换信息的过程中：

并行通信：多位数据通过多条数据线同时传送。

串行通信：多位数据通过同一条数据线按位传送。

单  工：只容许数据由一方发、一方收，单向通讯。

半双工：容许双向通讯，但是收发只能分时共用一路通道。

全双工：容许数据同时双向收发。

异步通信

一个字符一个字符地传输，每个字符一位一位地传输，传输一个字符时，以起始位开始，然后传输字符本身的各位，接着传输校验位，最后以停止位结束该字符的传输。一次传输的起始位、字符各位、校验位、停止位构成一组完整的信息，称为帧（Frame）。

帧与帧之间可有任意个空闲位。

起始位之后是数据的最低位。

同步通信

同步通信方式不给每个字符都加起始位和停止位，而把字符顺序的连接起来，组成一个数据块（首尾相连的数据串），把这样一个数据块称为一个信息桢。在数据的开始加上一个同步字符，而在信息的末尾加有一定的差错检验字符。

串行通信中，传输速率是用波特率来表示。所谓波特率是指单位时间内传送二进制数据的位数(简写为bps)。

## 9.5 文件存取I/O

### 9.5.1 文件存取有关概念

 DOS 系统功能调用 21H 的文件操作方法：文件代号式磁盘存取。

用户在处理一个文件时，必须给出完整的路径名，一旦文件的路径名送入操作系统，系统就返回给用户一个16位的二进制控制字，称为文件代号。

\[d:\]\[path\]filename.exe, 00

### 9.5.2 文件存取功能调用

建立磁盘文件

建立一个新文件或用同一个文件名重写一个旧文件时，首先要建立文件并赋给它一个属性，如果DOS发现要建立的文件已经存在，那么原来的文件就被破坏。

建立文件（3CH）
功能：按指定文件名建立文件。
入口参数：
(AH)＝3CH，
DS:DX指向ASCIZ字符串的段地址和偏移地址
(CX)＝文件属性。

出口参数：
若成功，则CF＝0，(AX)＝文件代号；
若失败，则CF＝1，(AX)＝错误代码。

打开文件（3DH）
功能：打开由ASCII  Z串指定的文件。
入口参数：
(AH)＝3DH，DS：DX指向ASCIZ字符串的段地址和偏移地址，(AL)＝存取代码（0：读文件，1：写文件，2：读、写文件）。
出口参数：
若成功，则CF＝0，（AX）＝文件代号；
若失败，则CF＝1，（AX）＝错误代码。

关闭文件（3EH）
功能：关闭文件代号指定的文件。
入口参数：
(AH)＝3EH，(BX)＝文件代号。
出口参数：
若操作成功，则CF＝0；
若操作失败，则CF＝1，（AX）＝错误代码。 

读文件（3FH）
入口参数：
(AH)＝3FH，(BX)＝文件代号，(CX)＝要读取的字节数；
DS：DX指向接收数据缓冲区的段地址和偏移地址。

出口参数：
若成功，则CF＝0，(AX)＝实际读入字节数，(AX)＝0，文件结束；
若失败，则CF＝1，(AX)＝错误代码。

写文件（40H）
入口参数：
(AH)＝40H，(BX)＝文件代号，(CX)＝要写入的字节数；
DS：DX指向存放写入信息数据缓冲区的段地址和偏移地址。

出口参数：
若成功，则CF＝0，(AX)＝写入字节数；
若失败，则CF＝1，(AX)＝错误代码。