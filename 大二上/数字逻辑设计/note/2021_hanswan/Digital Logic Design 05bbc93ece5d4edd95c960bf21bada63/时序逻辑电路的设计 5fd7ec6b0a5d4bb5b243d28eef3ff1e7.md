# 时序逻辑电路的设计

# 状态表的化简

如果两个状态满足：

- 对于各组输入，它们的输出是一样的。
- 对于各组输入，它们的次态
    - 完全相同；
    - 是它们本身，或者交错；
    - 某一后续状态可以合并；
    - 是一个状态对封闭链中的一个，

那么这两个状态可以合并而看成一个。利用这个原理，我们可以对状态表进行化简。

给定一个状态表：

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled.png)

画出如下的隐含表（竖列横排掐头去尾）

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%201.png)

然后填表。如果单元格左方和下方对应的两个状态的输出有不同，直接打「×」；如果两组输出相同，如果不仅输出相同，次态也相同或交错（例如，A → B，B → A），打「√」；如果输出相同但是次态有不同，将它们对应的下一跳状态写出来；

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%202.png)

接着，排查那些没有打「×」或打「√」的单元格，去检查它们对应的下一跳状态，将它们变成「×」或者「√」。

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%203.png)

打「√」表示这两个状态可以合并。合并完成的状态表如下：

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%204.png)

# 设计同步时序电路

与 [时序逻辑电路的分析](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%20a83a0a39c1df4005895ed19f9c115a6e.md) 中的方法完全相反，利用某一触发器来设计同步时序电路的步骤如下：

- 确定**状态和状态转换关系**。可能需要对原始状态图进行化简。
- 画出**状态转换表**。与前面的状态转换表不一样的是，这里的状态转换表多了触发器的输入栏——因为触发器的输入电路是我们需要得到的。
- 利用卡诺图化简得到：
    - 所有触发器的输入方程（和输入与现态有关）；
    - 所有输出项的方程（和输入与现态有关）；
- 画出电路。

下面以「使用 D 触发器设计 1111 检测器」为例。

先画出 Mealy 状态机的状态图：

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%205.png)

这是它的状态表：

| 现态 | X = 0 | X = 1 |
| --- | --- | --- |
| A | A / 0 | B / 0 |
| B | A / 0 | C / 0 |
| C | A / 0 | D / 0 |
| D | A / 0 | E / 1 |
| E | A / 0 | E / 1 |

显然可以将 D 和 E 状态合并，即：

| 现态 | X = 0 | X = 1 |
| --- | --- | --- |
| A | A / 0 | B / 0 |
| B | A / 0 | C / 0 |
| C | A / 0 | D / 0 |
| D | A / 0 | D / 1 |

一共需要 2 个 D 触发器。 为 A、B、C、D 四个状态分别编码 `00`、`01`、`10` 和 `11`，得到如下的状态图：

![**注意 10 和 11 对调一下位置，我画反了。**](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%206.png)

**注意 10 和 11 对调一下位置，我画反了。**

总的状态转换表如下。由于 D 触发器的次态就是 D 的值，填写 D1、D0 两栏十分的方便。

| 输入 X |  现态 Q1 | Q0 | 次态 Q1 | Q0 | D1 | D0 | 输出 Z |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |
| 1 | 0 | 1 | 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

画出 D1、D0 和 Z 关于 X、现态 Q1、现态 Q0 的卡诺图，圈出各自的最简式。

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%207.png)

画出电路：

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%208.png)

用 Logisim 验证一下（当然考试是不可能验证的了）：

*为什么我手画的图那么丑。*

![Untitled](%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%205fd7ec6b0a5d4bb5b243d28eef3ff1e7/Untitled%209.png)